<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1.0" name="viewport">
<title>Master QUIZ AUTO - Final (Compatible Cockpit)</title>
<style>
    /* --- STYLE √âDITEUR AM√âLIOR√â --- */
    :root { 
        --primary: #3498db; --success: #27ae60; --danger: #e74c3c; --dark: #2c3e50; 
        --warning: #f39c12; --purple: #8b5cf6; --teal: #14b8a6; --orange: #f97316;
    }
    body { 
        font-family: 'Segoe UI', sans-serif; max-width: 950px; margin: 0 auto; 
        padding: 20px; background: #f4f7f6; color: #333; padding-bottom: 120px; 
        transition: all 0.2s ease;
    }
    
    .container { 
        background: white; padding: 30px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); 
        border-radius: 12px; transition: box-shadow 0.3s ease; 
    }
    .container:hover { box-shadow: 0 6px 25px rgba(0,0,0,0.12); }
    
    h1 { 
        color: var(--dark); text-align: center; border-bottom: 3px solid var(--primary); 
        padding-bottom: 15px; margin-top: 0; position: relative;
    }
    
    /* COMPTEUR TEMPS R√âEL */
    .quiz-stats { 
        position: absolute; top: -5px; right: 0; background: var(--primary); 
        color: white; padding: 4px 12px; border-radius: 15px; font-size: 0.75em; 
        font-weight: bold; transition: all 0.3s ease;
    }
    .quiz-stats:hover { background: var(--dark); }
    
    .header-inputs { 
        display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 15px; margin-bottom: 25px; 
        background: linear-gradient(135deg, #eef2f3 0%, #f8f9fa 100%); 
        padding: 18px; border-radius: 10px; border: 1px solid #e0e6ed;
    }
    .input-group label { 
        display: block; font-size: 0.85em; font-weight: 600; color: #5a6c7d; 
        margin-bottom: 6px; transition: color 0.2s;
    }
    input, select, textarea { 
        padding: 11px 14px; border: 2px solid #e1e8ed; border-radius: 6px; width: 100%; 
        box-sizing: border-box; font-family: inherit; transition: all 0.2s ease;
        background: #fff;
    }
    input:focus, select:focus, textarea:focus {
        outline: none; border-color: var(--primary); 
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        transform: translateY(-1px);
    }
    
    /* Auto-Resize pour les zones de texte */
    textarea.auto-grow { 
        resize: none; overflow: hidden; min-height: 40px; height: auto; 
        transition: border-color 0.2s, box-shadow 0.2s; 
    }
    textarea.auto-grow:focus { 
        border-color: var(--primary); background: #fbfcfd; 
        box-shadow: 0 2px 8px rgba(52, 152, 219, 0.08);
    }

    /* BLOCS QUESTIONS AM√âLIOR√âS */
    .question-block { 
        background: #fff; border: 1px solid #e2e8f0; border-left: 5px solid var(--primary); 
        margin-bottom: 20px; padding: 18px; position: relative; border-radius: 8px; 
        box-shadow: 0 2px 8px rgba(0,0,0,0.04); transition: all 0.2s ease;
    }
    .question-block:hover { 
        box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
        transform: translateY(-1px);
    }
    .doc-block { 
        border-left-color: var(--warning); background: #fffcf5; 
        border: 1px solid #fed7aa;
    }
    
    .q-header { 
        display: flex; align-items: flex-start; margin-bottom: 15px; 
        background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); 
        padding: 12px 15px; border-radius: 6px; border-bottom: 1px solid #e2e8f0; gap: 12px; 
    }
    .q-num { 
        background: var(--primary); color: white; width: 28px; height: 28px; 
        display: flex; align-items: center; justify-content: center; border-radius: 50%; 
        font-size: 0.85em; font-weight: bold; margin-top: 6px; flex-shrink: 0;
        transition: all 0.2s ease;
    }
    .q-num:hover { background: var(--dark); transform: scale(1.05); }
    .doc-block .q-num { background: var(--warning); }

    .q-enonce { 
        flex: 1; font-weight: 600; border: none; background: transparent; 
        border-bottom: 2px dashed #cbd5e0; font-size: 1.05em; padding: 8px 0;
    }
    .q-enonce:focus { 
        border-bottom: 2px solid var(--primary); background: rgba(255,255,255,0.9);
        box-shadow: 0 2px 4px rgba(52, 152, 219, 0.1);
    }

    .q-controls { 
        display: flex; align-items: center; gap: 8px; margin-left: auto; 
    }
    .q-controls select, .q-controls input {
        font-weight: 600; font-size: 0.9em;
    }
    .delete-btn { 
        background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); 
        color: var(--danger); border: 1px solid #fca5a5; padding: 6px 12px; 
        cursor: pointer; border-radius: 6px; font-weight: 600; white-space: nowrap; 
        transition: all 0.2s ease; font-size: 0.85em;
    }
    .delete-btn:hover { 
        background: var(--danger); color: white; 
        transform: translateY(-1px); box-shadow: 0 4px 8px rgba(231, 76, 60, 0.2);
    }

    /* ZONES CONFIG AM√âLIOR√âES */
    .config-zone { 
        background: linear-gradient(135deg, #f1f8ff 0%, #f0f9ff 100%); 
        padding: 15px; margin-top: 12px; border-radius: 8px; 
        border: 1px dashed #93c5fd; box-shadow: 0 2px 4px rgba(59, 130, 246, 0.05);
    }
    .config-label { 
        font-weight: 600; font-size: 0.9em; color: #1e40af; 
        display: block; margin-bottom: 10px; 
    }
    
    .option-row { 
        display: flex; align-items: flex-start; gap: 12px; margin-bottom: 10px; 
        padding: 8px; background: rgba(255,255,255,0.7); border-radius: 6px;
        transition: all 0.2s ease;
    }
    .option-row:hover { 
        background: rgba(255,255,255,0.9); 
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .enc-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
    }
    .enc-table th, .enc-table td {
        border: 1px solid #cbd5e1;
        padding: 10px;
        vertical-align: top;
    }
    .enc-table th {
        background: #eff6ff;
        text-align: left;
        color: #1e3a8a;
    }
    .enc-label-cell {
        width: 34%;
        font-weight: 700;
        color: #1e293b;
        background: #f8fafc;
    }
    .enc-answer-cell textarea {
        width: 100%;
        min-height: 56px;
    }
    .enc-row-disabled {
        opacity: 0.45;
    }
    .enc-row-disabled .enc-expected {
        pointer-events: none;
        background: #e2e8f0;
    }
    .enc-toggle-btn {
        border: 1px solid #94a3b8;
        background: #fff;
        border-radius: 6px;
        cursor: pointer;
        padding: 2px 8px;
        font-weight: 700;
        color: #334155;
    }
    .correct-check { 
        width: 22px; height: 22px; cursor: pointer; accent-color: var(--success); 
        margin-top: 8px; transition: transform 0.2s;
    }
    .correct-check:hover { transform: scale(1.1); }
    
    /* TOOLBAR AM√âLIOR√âE */
    .tools-panel { 
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); 
        display: flex; gap: 6px; z-index: 2000; 
        background: linear-gradient(135deg, rgba(30, 41, 59, 0.95) 0%, rgba(15, 23, 42, 0.95) 100%); 
        padding: 15px 20px; border-radius: 16px; 
        box-shadow: 0 12px 40px rgba(0,0,0,0.3), 0 4px 20px rgba(0,0,0,0.2); 
        backdrop-filter: blur(12px); flex-wrap: wrap; justify-content: center; 
        width: 90%; max-width: 900px; border: 1px solid rgba(255,255,255,0.1);
    }
    .btn-tool { 
        padding: 11px 18px; border-radius: 8px; border: none; cursor: pointer; 
        font-weight: 600; color: white; font-size: 13px; 
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
        display: flex; align-items: center; gap: 8px;
        position: relative; overflow: hidden;
    }
    .btn-tool::before {
        content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.5s;
    }
    .btn-tool:hover::before { left: 100%; }
    .btn-tool:hover { 
        transform: translateY(-2px) scale(1.02); 
        filter: brightness(1.15);
        box-shadow: 0 8px 20px rgba(0,0,0,0.2);
    }
    
    .btn-qcm { background: linear-gradient(135deg, #3b82f6, #1d4ed8); } 
    .btn-vf { background: linear-gradient(135deg, #8b5cf6, #7c3aed); } 
    .btn-text { background: linear-gradient(135deg, #f97316, #ea580c); } 
    .btn-match { background: linear-gradient(135deg, #14b8a6, #0f766e); } 
    .btn-doc { background: linear-gradient(135deg, #f39c12, #d97706); }
    .btn-export { 
        background: linear-gradient(135deg, #22c55e, #16a34a); 
        border: 1px solid #15803d; font-size: 14px; padding: 12px 28px; 
        box-shadow: 0 6px 12px rgba(34, 197, 94, 0.25);
        font-weight: 700;
    }
    
    .insert-btn { 
        background: linear-gradient(135deg, var(--warning), #d97706); color: white; 
        border: none; padding: 8px 14px; border-radius: 6px; font-size: 0.85em; 
        font-weight: 600; cursor: pointer; margin-top: 12px; 
        transition: all 0.2s ease;
    }
    .insert-btn:hover { 
        background: linear-gradient(135deg, #d97706, #b45309); 
        transform: translateY(-1px); 
    }

    /* MODAL VALIDATION */
    .validation-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.6); z-index: 3000; display: none;
        align-items: center; justify-content: center; backdrop-filter: blur(4px);
    }
    .validation-content {
        background: white; padding: 30px; border-radius: 16px; max-width: 500px;
        width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        animation: modalSlide 0.3s ease-out;
    }
    @keyframes modalSlide {
        from { transform: translateY(-50px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }
    .validation-content h3 {
        color: var(--primary); margin-bottom: 20px; font-size: 1.3em;
        text-align: center;
    }
    .validation-list {
        max-height: 300px; overflow-y: auto; margin-bottom: 20px;
    }
    .validation-item {
        padding: 10px 15px; margin: 8px 0; border-radius: 6px;
        border-left: 4px solid #fbbf24; background: #fffbeb;
        font-size: 0.9em;
    }
    .validation-item.error { border-left-color: var(--danger); background: #fef2f2; }
    .validation-buttons {
        display: flex; gap: 12px; justify-content: center;
    }
    .btn-modal {
        padding: 10px 20px; border-radius: 6px; border: none; cursor: pointer;
        font-weight: 600; transition: all 0.2s;
    }
    .btn-cancel { background: #f3f4f6; color: #374151; }
    .btn-cancel:hover { background: #e5e7eb; }
    .btn-confirm { background: var(--success); color: white; }
    .btn-confirm:hover { background: #16a34a; }
    .btn-force { background: var(--danger); color: white; }
    .btn-force:hover { background: #dc2626; }

    /* SYST√àME NOTIFICATION */
    .notification {
        position: fixed; top: 20px; right: 20px; z-index: 4000;
        background: linear-gradient(135deg, #22c55e, #16a34a); color: white;
        padding: 12px 20px; border-radius: 8px; font-weight: 600;
        box-shadow: 0 8px 25px rgba(34, 197, 94, 0.3);
        transform: translateX(400px); opacity: 0;
        transition: all 0.3s ease;
    }
    .notification.show {
        transform: translateX(0); opacity: 1;
    }
    .notification.info {
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
    }

    /* ANIMATIONS SUBTILES */
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    .exporting { animation: pulse 1.5s infinite; }
    
    @keyframes slideIn {
        from { transform: translateX(-20px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    .question-block { animation: slideIn 0.3s ease-out; }
</style>
</head>
<body>

<div class="container">
    <h1>G√©n√©rateur de Quiz Auto v3.0 (Corrig√©)
        <span class="quiz-stats" id="quiz-stats">0 question - 0 pts</span>
    </h1>
    
    <div class="header-inputs">
        <div class="input-group">
            <label>Titre du Devoir</label>
            <input type="text" id="titre-devoir" value="√âvaluation" placeholder="Titre..." onchange="updateStats()">
        </div>
        <div class="input-group">
            <label>ID Unique (Fichier)</label>
            <input type="text" id="devoir-id" value="quiz_01" placeholder="ex: quiz_chapitre1">
        </div>
        <div class="input-group">
            <label>Niveau / Classe</label>
            <input type="text" id="niveau-cible" value="Bac Pro">
        </div>
    </div>

    <div id="quiz-content"></div>
    
    <div id="empty-msg" style="text-align:center; padding:50px; color:#64748b; border:2px dashed #cbd5e0; border-radius:12px; background:linear-gradient(135deg, #f8fafc, #f1f5f9);">
        <div style="font-size:1.2em; margin-bottom:10px;">üìù</div>
        Aucune question. Utilisez la barre d'outils en bas pour commencer üëá
    </div>
</div>

<div class="validation-modal" id="validation-modal">
    <div class="validation-content">
        <h3>üîç V√©rification du devoir</h3>
        <div class="validation-list" id="validation-list"></div>
        <div class="validation-buttons">
            <button class="btn-modal btn-cancel" onclick="closeValidation()">Corriger</button>
            <button class="btn-modal btn-confirm" onclick="exportAfterValidation()" id="btn-confirm-export">Exporter quand m√™me</button>
        </div>
    </div>
</div>

<div class="tools-panel">
    <button class="btn-tool btn-qcm" onclick="addBlock('QCU')">üîò QCU</button>
    <button class="btn-tool btn-qcm" onclick="addBlock('QCM')">‚òëÔ∏è QCM</button>
    <button class="btn-tool btn-vf" onclick="addBlock('VF')">‚úÖ Vrai/Faux</button>
    <button class="btn-tool btn-text" onclick="addBlock('NUMBER')">üî¢ Nombre</button>
    <button class="btn-tool btn-text" onclick="addBlock('SHORT')">‚úçÔ∏è Texte</button>
    <button class="btn-tool btn-text" onclick="addBlock('SELECT')">üìã Liste d√©roulante</button>
    <button class="btn-tool btn-text" onclick="addBlock('SEPARATOR')">‚ûñ S√©parateur</button>
    <button class="btn-tool btn-text" onclick="addBlock('TITLE')">üî§ Titre</button>
    <button class="btn-tool btn-text" onclick="addBlock('BOX_NOTE')">üóíÔ∏è Note</button>
    <button class="btn-tool btn-text" onclick="addBlock('IMAGE')">üñºÔ∏è Image seule</button>
    <button class="btn-tool btn-text" onclick="addBlock('QQOQCP')">üß© QQOQCP</button>
    <button class="btn-tool btn-text" onclick="addBlock('PAD')">‚ö†Ô∏è PAD</button>
    <button class="btn-tool btn-text" onclick="addBlock('ITAMAMI')">üß∞ ITAMAMI</button>
    <span style="width:1px;background:rgba(255,255,255,0.2);margin:0 8px;"></span>
    <button class="btn-tool btn-doc" onclick="addBlock('DOC')">üìÑ Doc</button>
    <span style="width:1px;background:rgba(255,255,255,0.2);margin:0 8px;"></span>
    <button class="btn-tool" style="background:linear-gradient(135deg, #8b5cf6, #7c3aed);" onclick="exportTemplate()">üì§ Template IA</button>
    <button class="btn-tool" style="background:linear-gradient(135deg, #0ea5e9, #0284c7);" onclick="saveDraftJSON()">üíæ Sauvegarder JSON</button>
    <button class="btn-tool" style="background:linear-gradient(135deg, #06b6d4, #0891b2);" onclick="importJSON()">üì• Import JSON</button>
    <button class="btn-tool" style="background:linear-gradient(135deg, #0891b2, #0e7490);" onclick="importJSONFromPaste()">üìù Coller JSON</button>
    <span style="width:1px;background:rgba(255,255,255,0.2);margin:0 8px;"></span>
    <button class="btn-tool btn-export" onclick="attemptExport()">üöÄ EXPORTER</button>
</div>

<script>
    let qCount = 0;
    window.MasterWidgets = window.MasterWidgets || (function() {
        const registry = {};
        return {
            register(type, def) {
                if (!type || !def || typeof def !== "object") return;
                registry[type] = def;
            },
            get(type) {
                return registry[type] || null;
            },
            all() {
                return registry;
            },
            init() {
                this._initialized = true;
            }
        };
    })();

    function normalizeImagePath(rawPath) {
        const p = String(rawPath || "").trim();
        if (!p) return "";
        if (/^(https?:)?\/\//i.test(p) || p.startsWith("/") || p.startsWith("./") || p.startsWith("../")) return p;
        if (p.includes("/")) return p;
        return "images/" + p;
    }

    function updateImagePreview(input) {
        const wrap = input.closest(".image-widget-editor");
        if (!wrap) return;
        const img = wrap.querySelector(".image-preview");
        if (!img) return;
        const src = normalizeImagePath(input.value);
        if (!src) {
            img.style.display = "none";
            img.removeAttribute("src");
            return;
        }
        img.src = src;
        img.style.display = "block";
    }

    function normalizeFrameKey(value) {
        return String(value || "")
            .toLowerCase()
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .replace(/[^a-z0-9]+/g, "_")
            .replace(/^_+|_+$/g, "");
    }

    function parseFrameOptions(raw) {
        return String(raw || "")
            .split(/[;\n]/)
            .map((s) => s.trim())
            .filter(Boolean)
            .map((label, idx) => ({ value: `opt${idx + 1}`, label }));
    }

    function resolveFrameRows(def) {
        return (def.lines || []).map((line) => {
            if (typeof line === "string") {
                const key = normalizeFrameKey(line);
                return { key, label: line };
            }
            return {
                key: normalizeFrameKey(line.key || line.label),
                label: line.label || line.key || "Ligne"
            };
        });
    }

    function createEncWidgetDef(title, lines, slug) {
        return {
            kind: "enc",
            countAsQuestion: true,
            title,
            lines,
            slug: slug || normalizeFrameKey(title),
            exportToBlueprint(block, ctx) {
                const rows = getActiveEncRows(block);
                if (!rows.length) return [];
                const mode = String(block.querySelector(".enc-mode")?.value || "TEXT").toUpperCase();
                const rowPoints = splitPoints(ctx.bareme, rows.length);
                const explanation = block.querySelector('.q-explain')?.value?.trim() || "";
                return rows.map((row, idx) => {
                    const subkey = row.dataset.subkey || normalizeFrameKey(row.dataset.label || `ligne_${idx + 1}`);
                    const subqid = row.dataset.subqid || `${ctx.qidBase}_${this.slug}_${subkey}`;
                    row.dataset.subqid = subqid;
                    const lineLabel = row.dataset.label || `Ligne ${idx + 1}`;
                    const item = {
                        type: "question",
                        qid: subqid,
                        label: `${ctx.qCounter}.${idx + 1}`,
                        competence: ctx.competence,
                        bareme: rowPoints[idx] ?? 0,
                        questionText: `${ctx.enoncePlain} ‚Äî ${lineLabel}`,
                        reponseAttendue: explanation
                    };
                    if (mode === "SELECT") {
                        const opts = parseFrameOptions(row.querySelector(".enc-select-options")?.value || "");
                        const rawCorrect = String(row.querySelector(".enc-select-correct")?.value || "").trim();
                        const validCorrect = opts.some((opt) => opt.value === rawCorrect) ? rawCorrect : "";
                        const canAutocorrect = opts.length >= 2 && !!validCorrect;
                        item.inputType = "select";
                        item.options = opts;
                        item.reponseCorrecte = validCorrect;
                        item.autocorrect = canAutocorrect;
                        item.besoinCorrectionManuelle = !canAutocorrect;
                    } else {
                        item.inputType = "texte_exact";
                        item.reponseCorrecte = [];
                        item.autocorrect = false;
                        item.besoinCorrectionManuelle = true;
                    }
                    return item;
                });
            },
            exportToStudentHTML(block, ctx) {
                const rows = getActiveEncRows(block);
                if (!rows.length) return "";
                const mode = String(block.querySelector(".enc-mode")?.value || "TEXT").toUpperCase();
                let html = `
                    <div class="question-block">
                        <span class="q-label">${ctx.qCounter}</span><span class="q-comp">${ctx.competence}</span><span class="q-points">${ctx.bareme} pts</span>
                        <div class="q-text">${ctx.enonceHtml}</div>
                        <div class="table-wrapper">
                            <table class="eval-table">
                                <tbody>
                `;
                rows.forEach((row, idx) => {
                    const lineLabel = row.dataset.label || `Ligne ${idx + 1}`;
                    const subkey = row.dataset.subkey || normalizeFrameKey(lineLabel);
                    const subqid = row.dataset.subqid || `${ctx.qidBase}_${this.slug}_${subkey}`;
                    row.dataset.subqid = subqid;
                    let cellHtml = `<textarea class="reponse-eleve answer-input" data-qid="${subqid}" rows="2" style="width:100%; min-height:54px;" placeholder="Votre r√©ponse"></textarea>`;
                    if (mode === "SELECT") {
                        const opts = parseFrameOptions(row.querySelector(".enc-select-options")?.value || "");
                        const optsHtml = [`<option value="">-- S√©lectionner --</option>`]
                            .concat(opts.map((opt) => `<option value="${opt.value}">${opt.label}</option>`))
                            .join("");
                        cellHtml = `<select class="reponse-eleve answer-select" data-qid="${subqid}">${optsHtml}</select>`;
                    }
                    html += `
                        <tr>
                            <td>${lineLabel}</td>
                            <td>${cellHtml}</td>
                        </tr>
                    `;
                });
                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
                return html;
            },
            importFromBlueprint(items) {
                const first = items[0] || {};
                const titlePart = String(first.questionText || "").split("‚Äî")[0].trim();
                const competence = first.competence || first.comp || "C1";
                const total = items.reduce((sum, i) => sum + (parseFloat(i.bareme || i.points || 0) || 0), 0);
                return {
                    enonce: titlePart,
                    competence,
                    points: Number(total.toFixed(2)),
                    explanation: getFlexibleText(first, ['reponseAttendue', 'explication', 'correction', 'justification']),
                    lignes: items.map((i) => ({
                        label: String(i.questionText || "").split("‚Äî")[1]?.trim() || "",
                        subqid: i.qid || createStableQid(),
                        enabled: true,
                        preview: Array.isArray(i.reponseCorrecte) ? i.reponseCorrecte.join("; ") : String(i.reponseCorrecte || "")
                    }))
                };
            }
        };
    }

    window.MasterWidgets.register("SEPARATOR", {
        kind: "visual",
        countAsQuestion: false,
        exportToBlueprint() { return []; },
        exportToStudentHTML() {
            return `<div class="document-box" style="background:#f8fafc;border-color:#cbd5e1;"><hr style="border:none;border-top:3px solid #94a3b8;"></div>`;
        },
        importFromBlueprint() { return null; }
    });
    window.MasterWidgets.register("TITLE", {
        kind: "visual",
        countAsQuestion: false,
        exportToBlueprint() { return []; },
        exportToStudentHTML(block) {
            const text = block.querySelector('.q-enonce')?.value || "";
            return `<div class="document-box" style="background:#eef2ff;border-color:#a5b4fc;"><h4 style="margin:0;">${text}</h4></div>`;
        },
        importFromBlueprint() { return null; }
    });
    window.MasterWidgets.register("BOX_NOTE", {
        kind: "visual",
        countAsQuestion: false,
        exportToBlueprint() { return []; },
        exportToStudentHTML(block) {
            const title = block.querySelector('.q-enonce')?.value || "Note";
            const content = (block.querySelector('.box-note-content')?.value || "").replace(/\n/g, "<br>");
            return `<div class="document-box" style="background:#fff7ed;border-color:#fdba74;"><h4>${title}</h4><p>${content}</p></div>`;
        },
        importFromBlueprint() { return null; }
    });
    window.MasterWidgets.register("IMAGE", {
        kind: "visual",
        countAsQuestion: false,
        renderEditor(ctx) {
            ctx.content.innerHTML = `
                <div class="config-zone image-widget-editor" style="background:#f8fafc; border-color:#cbd5e1;">
                    <span class="config-label">Image seule (non export blueprint, nom simple => images/nom.ext)</span>
                    <input type="text" class="image-path-input" placeholder="ex: schema1.png ou images/schema1.png" oninput="updateImagePreview(this)" style="width:100%; margin-bottom:8px;">
                    <img class="image-preview" alt="Aper√ßu image" style="display:none; max-width:100%; border:1px solid #cbd5e1; border-radius:8px;">
                </div>
            `;
            const enonceField = ctx.block ? ctx.block.querySelector(".q-enonce") : null;
            if (enonceField && !enonceField.value.trim()) {
                enonceField.value = "Illustration";
                autoResize(enonceField);
            }
        },
        exportToBlueprint() { return []; },
        exportToStudentHTML(block, ctx) {
            const raw = block.querySelector(".image-path-input")?.value || "";
            const src = normalizeImagePath(raw);
            if (!src) return "";
            const title = ctx.enoncePlain || "Illustration";
            return `<div class="document-box"><h4>${title}</h4><img src="${src}" alt="${title}" style="max-width:100%; height:auto; border-radius:8px;"></div>`;
        },
        importFromBlueprint() { return null; }
    });
    window.MasterWidgets.register("QQOQCP", createEncWidgetDef("Compl√©ter le tableau QQOQCP", [
        { key: "qui", label: "QUI" },
        { key: "quoi", label: "QUOI" },
        { key: "ou", label: "OU" },
        { key: "quand", label: "QUAND" },
        { key: "comment", label: "COMMENT" },
        { key: "pourquoi", label: "POURQUOI" }
    ], "qqoqcp"));
    window.MasterWidgets.register("PAD", createEncWidgetDef("Compl√©ter le tableau PAD", [
        { key: "operateur", label: "OPERATEUR" },
        { key: "danger", label: "DANGER" },
        { key: "situation_dangereuse", label: "SITUATION_DANGEREUSE" },
        { key: "evenement_declencheur", label: "EVENEMENT_DECLENCHEUR" },
        { key: "dommage", label: "DOMMAGE" }
    ], "pad"));
    window.MasterWidgets.register("ITAMAMI", createEncWidgetDef("Compl√©ter le tableau ITAMAMI", [
        { key: "individu", label: "INDIVIDU" },
        { key: "tache", label: "TACHE" },
        { key: "activite", label: "ACTIVITE" }
    ], "itamami"));
    // Alias legacy
    window.MasterWidgets.register("ENC_KQQOQCP", getWidgetDef("QQOQCP"));
    window.MasterWidgets.register("ENC_PAD", getWidgetDef("PAD"));
    window.MasterWidgets.register("ENC_ITAMAMI", getWidgetDef("ITAMAMI"));

    function createStableQid() {
        return `q_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
    }

    function getWidgetDef(type) {
        return window.MasterWidgets && typeof window.MasterWidgets.get === "function"
            ? window.MasterWidgets.get(type)
            : null;
    }

    function isWidgetType(type) {
        return !!getWidgetDef(type);
    }

    function isVisualWidgetType(type) {
        const def = getWidgetDef(type);
        return !!(def && def.countAsQuestion === false);
    }

    function countsAsQuestionType(type) {
        if (type === "DOC") return false;
        return !isVisualWidgetType(type);
    }

    function getCountedQuestionBlocks() {
        return Array.from(document.querySelectorAll('.question-block')).filter((block) => countsAsQuestionType(block.dataset.type));
    }

    function isNonExportWidgetType(type) {
        return ["SEPARATOR", "TITLE", "BOX_NOTE", "IMAGE"].includes(type);
    }

    function renderWidgetBlock(type, block, ctx) {
        const def = getWidgetDef(type);
        if (!def || typeof def.exportToStudentHTML !== "function") return "";
        return def.exportToStudentHTML(block, ctx) || "";
    }

    function renderWidgetButtons() {
        const panel = document.querySelector('.tools-panel');
        if (!panel) return;
        const defs = window.MasterWidgets.all();
        Object.keys(defs).forEach((type) => {
            const def = defs[type];
            if (!def || !def.toolbarLabel) return;
            if (panel.querySelector(`[data-widget-type="${type}"]`)) return;
            const btn = document.createElement('button');
            btn.className = `btn-tool ${def.toolbarClass || ''}`.trim();
            btn.setAttribute('data-widget-type', type);
            btn.textContent = def.toolbarLabel;
            btn.onclick = () => addBlock(type);
            panel.insertBefore(btn, panel.firstChild);
        });
    }

    function isEncType(type) {
        const def = getWidgetDef(type);
        return !!(def && def.kind === "enc");
    }

    function normalizeEncLabel(label) {
        return String(label || "")
            .toLowerCase()
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .replace(/[^a-z0-9]+/g, " ")
            .replace(/\s+/g, " ")
            .trim();
    }

    function getEncTypeFromLabel(label) {
        const norm = normalizeEncLabel(label);
        const allTypes = Object.keys(window.MasterWidgets.all()).filter((type) => isEncType(type));
        for (let i = 0; i < allTypes.length; i++) {
            const type = allTypes[i];
            const lines = resolveFrameRows(getWidgetDef(type) || {});
            const found = lines.some((line) => normalizeEncLabel(line.label) === norm);
            if (found) return type;
        }
        return null;
    }

    function setEncRowEnabled(row, enabled) {
        row.dataset.enabled = enabled ? "1" : "0";
        row.classList.toggle("enc-row-disabled", !enabled);
        const answer = row.querySelector(".enc-expected");
        if (answer) answer.disabled = !enabled;
        const btn = row.querySelector(".enc-toggle-btn");
        if (btn) {
            btn.textContent = enabled ? "√ó" : "‚Ü∫";
            btn.title = enabled ? "D√©sactiver cette ligne" : "R√©activer cette ligne";
        }
    }

    function toggleEncRow(btn) {
        const row = btn.closest(".enc-row");
        if (!row) return;
        const enabled = row.dataset.enabled !== "0";
        setEncRowEnabled(row, !enabled);
    }

    function getEncRows(block) {
        return Array.from(block.querySelectorAll(".enc-row"));
    }

    function getActiveEncRows(block) {
        return getEncRows(block).filter((row) => row.dataset.enabled !== "0");
    }

    function setEncMode(source, forcedMode = null) {
        const block = source && source.classList && source.classList.contains("question-block")
            ? source
            : (source && typeof source.closest === "function" ? source.closest(".question-block") : null);
        if (!block) return;
        const modeEl = block.querySelector(".enc-mode");
        const mode = String(forcedMode || modeEl?.value || "TEXT").toUpperCase();
        if (modeEl) modeEl.value = mode;
        block.dataset.encMode = mode;
        block.querySelectorAll(".enc-select-config").forEach((el) => {
            el.style.display = mode === "SELECT" ? "block" : "none";
        });
    }

    function splitPoints(total, count) {
        const c = Math.max(0, Number(count) || 0);
        if (c === 0) return [];
        const t = Number(total) || 0;
        const base = Math.floor((t * 100) / c) / 100;
        const points = Array.from({ length: c }, () => base);
        const used = base * (c - 1);
        points[c - 1] = Number((t - used).toFixed(2));
        return points;
    }

    // --- MISE √Ä JOUR COMPTEUR ---
    function updateStats() {
        const questions = getCountedQuestionBlocks().length;
        let totalPoints = 0;
        getCountedQuestionBlocks().forEach((block) => {
            totalPoints += parseFloat(block.querySelector('.q-points')?.value) || 0;
        });
        document.getElementById('quiz-stats').textContent = 
            `${questions} question${questions > 1 ? 's' : ''} - ${totalPoints} pt${totalPoints > 1 ? 's' : ''}`;
    }

    // --- FONCTION AUTO-RESIZE ---
    function autoResize(el) {
        el.style.height = 'auto';
        el.style.height = el.scrollHeight + 'px';
    }

    // --- FONCTIONS DE BASE ---
    function insertAfter(newNode, referenceNode) {
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
    }

    function removeBlock(btn) {
        if(confirm("Supprimer ce bloc ?")) {
            btn.closest('.question-block').remove();
            renumberQuestions();
            updateStats();
            if(document.querySelectorAll('.question-block').length === 0) {
                document.getElementById('empty-msg').style.display = 'block';
            }
        }
    }

    function renumberQuestions() {
        let i = 1;
        getCountedQuestionBlocks().forEach(el => {
            el.querySelector('.q-num').textContent = i++;
        });
        document.querySelectorAll('.question-block').forEach((el) => {
            const type = el.dataset.type;
            if (!countsAsQuestionType(type)) {
                const numEl = el.querySelector('.q-num');
                if (numEl) numEl.textContent = "‚Ä¢";
            }
        });
        qCount = i - 1;
    }

    // --- CR√âATION DE BLOCS ---
    function createBlockSkeleton(type, insertAfterElem = null) {
        document.getElementById('empty-msg').style.display = 'none';
        
        const div = document.createElement('div');
        div.className = `question-block ${type === 'DOC' ? 'doc-block' : ''}`;
        div.dataset.type = type;
        div.dataset.qid = createStableQid();
        
        let headerHtml = '';
        
        if (type === 'DOC') {
            headerHtml = `
                <div class="q-header" style="background:linear-gradient(135deg, #fff3cd 0%, #fef3c7 100%); border-color:#fbbf24;">
                    <div class="q-num">üìÑ</div>
                    <textarea class="doc-title-input auto-grow" rows="1" placeholder="Titre du document" oninput="autoResize(this)" style="font-weight:bold; background:transparent; border:none; border-bottom:2px dashed #f59e0b; color:#d97706; flex:1;"></textarea>
                    <button class="delete-btn" onclick="removeBlock(this)">Supprimer</button>
                </div>
            `;
        } else {
            if (countsAsQuestionType(type)) qCount++;
            headerHtml = `
                <div class="q-header">
                    <div class="q-num">${countsAsQuestionType(type) ? qCount : "‚Ä¢"}</div>
                    <textarea class="q-enonce auto-grow" rows="1" placeholder="√ânonc√© de la question..." oninput="autoResize(this)"></textarea>
                    <div class="q-controls">
                        <select class="q-comp" style="width:80px; font-weight:bold;" onchange="updateStats()">
                            <option value="C1">C1</option><option value="C2">C2</option><option value="C3">C3</option><option value="C4">C4</option><option value="C5">C5</option><option value="C6">C6</option>
                        </select>
                        <input type="number" class="q-points" value="1" step="0.5" style="width:60px; text-align:center; font-weight:bold;" title="Points" onchange="updateStats()">
                        <button class="delete-btn" onclick="removeBlock(this)">‚úï</button>
                    </div>
                </div>
            `;
        }
        
        div.innerHTML = headerHtml + `<div class="block-content"></div>`;
        
        if (type === 'DOC') {
             div.innerHTML += `<button class="insert-btn" onclick="addQuestionAfter(this)">‚ûï Ajouter une question sous ce document</button>`;
        }

        const container = document.getElementById('quiz-content');
        if (insertAfterElem) {
            insertAfter(div, insertAfterElem);
        } else {
            container.appendChild(div);
        }
        
        div.querySelectorAll('textarea.auto-grow').forEach(ta => autoResize(ta));
        setTimeout(() => div.scrollIntoView({behavior: "smooth", block: "center"}), 100);
        renumberQuestions();
        updateStats();
        return div.querySelector('.block-content');
    }

    function addQuestionAfter(btn) {
        const block = btn.closest('.question-block');
        addBlock('QCU', block);
    }

    function addBlock(type, insertAfterElem = null) {
        const content = createBlockSkeleton(type, insertAfterElem);
        const uid = Date.now();

        if (type === 'QCU' || type === 'SELECT' || type === 'QCM') {
            const containerId = `opts_${uid}`;
            const isQcm = type === "QCM";
            content.innerHTML = `
                <div class="config-zone">
                    <span class="config-label">üìù Options (${type === "SELECT" ? "Liste d√©roulante : cochez la bonne r√©ponse" : (isQcm ? "QCM : cochez les bonnes r√©ponses" : "QCU : cochez la bonne r√©ponse")})</span>
                    <div id="${containerId}"></div>
                    <button onclick="addOption('${containerId}', '${isQcm ? "multi" : "single"}')" style="margin-top:10px;font-size:0.85em;cursor:pointer;background:linear-gradient(135deg, #e9ecef, #dee2e6);border:none;padding:6px 12px;border-radius:6px;font-weight:bold;color:#495057;transition:all 0.2s;">+ Ajouter une option</button>
                </div>
            `;
            addOption(containerId, isQcm ? "multi" : "single");
            addOption(containerId, isQcm ? "multi" : "single");
        } 
        else if (type === 'VF') {
            content.innerHTML = `
                <div class="config-zone" style="background:linear-gradient(135deg, #e8f5e9 0%, #f0fdf4 100%); border-color:#86efac;">
                    <span class="config-label" style="color:#15803d;">üéØ R√©ponse attendue</span>
                    <label style="cursor:pointer;margin-right:20px;font-weight:bold;color:#15803d;"><input type="radio" name="vf_${uid}" value="vrai" checked> Vrai</label>
                    <label style="cursor:pointer;font-weight:bold;color:#dc2626;"><input type="radio" name="vf_${uid}" value="faux"> Faux</label>
                </div>
            `;
        }
        else if (type === 'SHORT' || type === 'NUMBER') {
            content.innerHTML = `
                <div class="config-zone">
                    <span class="config-label">üéØ R√©ponse attendue</span>
                    <textarea class="valid-answers auto-grow" rows="1" oninput="autoResize(this)" placeholder="${type === 'NUMBER' ? 'Ex: 10' : 'Ex: Paris; la capitale'}" style="border:2px solid #22c55e; font-family:monospace; font-weight:bold; color:#15803d; width:100%;"></textarea>
                </div>
            `;
        }
        else if (isEncType(type)) {
            const def = getWidgetDef(type);
            const block = content.closest(".question-block");
            const qidBase = block?.dataset?.qid || createStableQid();
            const rowsHtml = resolveFrameRows(def).map((lineDef) => {
                const subqid = `${qidBase}_${def.slug || normalizeFrameKey(type)}_${lineDef.key}`;
                return `
                <tr class="enc-row" data-label="${lineDef.label}" data-subkey="${lineDef.key}" data-subqid="${subqid}" data-enabled="1">
                    <td class="enc-label-cell">${lineDef.label}</td>
                    <td class="enc-answer-cell">
                        <textarea class="enc-expected auto-grow" rows="2" oninput="autoResize(this)" placeholder="R√©ponse attendue (optionnelle)..."></textarea>
                        <div class="enc-select-config" style="display:none; margin-top:8px;">
                            <textarea class="enc-select-options auto-grow" rows="1" oninput="autoResize(this)" placeholder="Options (s√©par√©es par ; ou retour ligne)"></textarea>
                            <input class="enc-select-correct" type="text" placeholder="R√©ponse correcte (ex: opt1)" style="margin-top:6px;">
                        </div>
                    </td>
                    <td style="width:76px; text-align:center;"><span style="font-size:0.8em; color:#64748b;">fixe</span></td>
                </tr>
            `;
            }).join("");

            content.innerHTML = `
                <div class="config-zone" style="background:linear-gradient(135deg, #eef2ff 0%, #f8fafc 100%); border-color:#a5b4fc;">
                    <div style="display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom:10px;">
                        <span class="config-label">üß© Tableau encadr√© (${resolveFrameRows(def).length} lignes fixes)</span>
                        <label style="font-size:0.85em; font-weight:700;">Mode:
                            <select class="enc-mode" onchange="setEncMode(this)">
                                <option value="TEXT">TEXTE</option>
                                <option value="SELECT">LISTE DEROULANTE</option>
                            </select>
                        </label>
                    </div>
                    <table class="enc-table" aria-label="Tableau encadr√©">
                        <thead>
                            <tr>
                                <th>Rubrique</th>
                                <th>R√©ponse attendue / guide</th>
                                <th>Actif</th>
                            </tr>
                        </thead>
                        <tbody>${rowsHtml}</tbody>
                    </table>
                </div>
            `;

            if (block) block.classList.add("enc-block");
            const enonceField = block ? block.querySelector(".q-enonce") : null;
            if (enonceField && !enonceField.value.trim()) {
                enonceField.value = def.title;
                autoResize(enonceField);
            }
            setEncMode(block, "TEXT");
        }
        else if (type === 'SEPARATOR') {
            content.innerHTML = `
                <div class="config-zone" style="background:#f8fafc; border-color:#cbd5e1;">
                    <span class="config-label">S√©parateur visuel (non export√© dans le blueprint)</span>
                    <hr style="border:none; border-top:3px solid #94a3b8; margin:12px 0;">
                </div>
            `;
        }
        else if (type === 'TITLE') {
            content.innerHTML = `
                <div class="config-zone" style="background:#f8fafc; border-color:#cbd5e1;">
                    <span class="config-label">Titre intercal√© (non export√© dans le blueprint)</span>
                    <p style="font-weight:700; color:#334155;">Ce bloc sert uniquement de mise en forme.</p>
                </div>
            `;
            const block = content.closest(".question-block");
            const enonceField = block ? block.querySelector(".q-enonce") : null;
            if (enonceField && !enonceField.value.trim()) {
                enonceField.value = "Titre de section";
                autoResize(enonceField);
            }
        }
        else if (type === 'BOX_NOTE') {
            content.innerHTML = `
                <div class="config-zone" style="background:#fff7ed; border-color:#fdba74;">
                    <span class="config-label">Encadr√© note/aide (non export√© dans le blueprint)</span>
                    <textarea class="box-note-content auto-grow" rows="3" oninput="autoResize(this)" placeholder="Texte de note ou d'aide..."></textarea>
                </div>
            `;
            const block = content.closest(".question-block");
            const enonceField = block ? block.querySelector(".q-enonce") : null;
            if (enonceField && !enonceField.value.trim()) {
                enonceField.value = "Note";
                autoResize(enonceField);
            }
        }
        else if (isWidgetType(type) && typeof getWidgetDef(type).renderEditor === "function") {
            try {
                getWidgetDef(type).renderEditor({
                    type,
                    content,
                    block: content.closest('.question-block'),
                    helpers: { createStableQid, autoResize, setEncRowEnabled, getEncRows }
                });
            } catch (err) {
                content.innerHTML = `<div class="config-zone">Erreur widget: ${String(err.message || err)}</div>`;
            }
        }
        else if (type === 'DOC') {
            content.innerHTML = `
                <textarea class="doc-content auto-grow" style="min-height:100px; width:100%;" placeholder="Contenu du document..." oninput="autoResize(this)"></textarea>
            `;
        }
        
        if (type !== 'DOC' && !isNonExportWidgetType(type)) {
            content.innerHTML += `
                <div style="margin-top:15px;">
                    <textarea class="q-explain auto-grow" rows="1" oninput="autoResize(this)" placeholder="üí° Explication pour la correction..." style="font-size:0.9em;color:#64748b;background:#f8fafc;border:2px dashed #cbd5e0;width:100%;border-radius:6px;padding:10px;"></textarea>
                </div>
            `;
        }
    }

    function addOption(containerId, mode = "single") {
        const div = document.createElement('div');
        div.className = 'option-row';
        const isMulti = mode === "multi";
        const inputType = isMulti ? 'checkbox' : 'radio';
        const nameGroup = `grp_${containerId}`;
        div.innerHTML = `
            <input type="${inputType}" ${isMulti ? '' : `name="${nameGroup}"`} class="correct-check" title="Est-ce la bonne r√©ponse ?">
            <textarea class="opt-text auto-grow" rows="1" oninput="autoResize(this)" placeholder="R√©ponse possible..."></textarea>
            <button onclick="this.parentElement.remove()" style="color:#e74c3c;border:none;background:none;cursor:pointer;font-weight:bold;margin-top:10px;font-size:1.2em;transition:all 0.2s;" onmouseover="this.style.color='#dc2626'; this.style.transform='scale(1.2)'" onmouseout="this.style.color='#e74c3c'; this.style.transform='scale(1)'">√ó</button>
        `;
        document.getElementById(containerId).appendChild(div);
    }

    // ============================================================
    // üîç SYST√àME DE VALIDATION
    // ============================================================

    function validateQuiz() {
        const issues = [];
        const warnings = [];
        
        // V√©rifications de base
        const titre = document.getElementById('titre-devoir').value.trim();
        const devoirId = document.getElementById('devoir-id').value.trim();
        
        if (!titre) issues.push("‚ùå Titre du devoir manquant");
        if (!devoirId) issues.push("‚ùå ID unique manquant");
        
        // V√©rification RGPD basique
        if (titre.match(/\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/)) {
            issues.push("‚ö†Ô∏è RGPD : Le titre semble contenir un nom/pr√©nom");
        }
        
        // V√©rification des questions
        const questions = getCountedQuestionBlocks();
        if (questions.length === 0) {
            issues.push("‚ùå Aucune question cr√©√©e");
            return { issues, warnings, canExport: false };
        }
        
        let totalPoints = 0;
        const competences = new Set();
        
        questions.forEach((q, idx) => {
            const num = idx + 1;
            const enonce = q.querySelector('.q-enonce').value.trim();
            const points = parseFloat(q.querySelector('.q-points').value) || 0;
            const comp = q.querySelector('.q-comp').value;
            const type = q.dataset.type;
            
            if (!enonce) issues.push(`‚ùå Question ${num} : √©nonc√© manquant`);
            if (points <= 0) warnings.push(`‚ö†Ô∏è Question ${num} : bar√®me invalide (${points})`);
            
            // V√©rification RGPD dans les √©nonc√©s
            if (enonce.match(/\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/)) {
                issues.push(`‚ö†Ô∏è RGPD : Question ${num} semble contenir un nom/pr√©nom`);
            }
            
            totalPoints += points;
            competences.add(comp);
            
            // V√©rifications sp√©cifiques par type
            if (type === 'QCU' || type === 'SELECT' || type === 'QCM') {
                const options = q.querySelectorAll('.opt-text');
                const checked = q.querySelectorAll('.correct-check:checked');
                
                let validOptions = 0;
                options.forEach(opt => {
                    if (opt.value.trim()) validOptions++;
                });
                
                if (validOptions < 2) warnings.push(`‚ö†Ô∏è Question ${num} : moins de 2 options valides`);
                if (checked.length === 0) issues.push(`‚ùå Question ${num} : aucune bonne r√©ponse coch√©e`);
                if ((type === 'QCU' || type === 'SELECT') && checked.length > 1) issues.push(`‚ùå Question ${num} : ${type} avec plusieurs bonnes r√©ponses`);
                if (type === 'QCM' && checked.length === 1) warnings.push(`‚ö†Ô∏è Question ${num} : QCM avec une seule bonne r√©ponse`);
            }
            
            if (type === 'SHORT' || type === 'NUMBER') {
                const reponse = q.querySelector('.valid-answers').value.trim();
                if (!reponse) issues.push(`‚ùå Question ${num} : r√©ponse attendue manquante`);
            }

            if (isEncType(type)) {
                const activeRows = getActiveEncRows(q);
                if (activeRows.length === 0) {
                    issues.push(`‚ùå Question ${num} : aucune ligne active dans l'encadr√©`);
                }
                if (points <= 0) {
                    issues.push(`‚ùå Question ${num} : bar√®me encadr√© invalide (${points})`);
                }
                const mode = String(q.querySelector('.enc-mode')?.value || 'TEXT').toUpperCase();
                if (mode === 'SELECT') {
                    activeRows.forEach((row, ridx) => {
                        const opts = parseFrameOptions(row.querySelector('.enc-select-options')?.value || '');
                        const correct = String(row.querySelector('.enc-select-correct')?.value || '').trim();
                        if (opts.length < 2) issues.push(`‚ùå Question ${num}, ligne ${ridx + 1} : liste d√©roulante avec moins de 2 options.`);
                        if (!correct) issues.push(`‚ùå Question ${num}, ligne ${ridx + 1} : r√©ponse correcte manquante (mode liste).`);
                    });
                }
            }
            
        });
        
        // Statistiques globales
        if (totalPoints === 0) issues.push("‚ùå Total des points = 0");
        if (totalPoints > 20) warnings.push(`‚ö†Ô∏è Total √©lev√© : ${totalPoints} points`);
        if (competences.size === 1) warnings.push(`‚ö†Ô∏è Une seule comp√©tence utilis√©e : ${Array.from(competences)[0]}`);
        
        return { issues, warnings, canExport: issues.length === 0 };
    }

    function showValidation(validation) {
        const modal = document.getElementById('validation-modal');
        const list = document.getElementById('validation-list');
        const confirmBtn = document.getElementById('btn-confirm-export');
        
        list.innerHTML = '';
        
        if (validation.issues.length === 0 && validation.warnings.length === 0) {
            list.innerHTML = '<div style="text-align:center; color:#059669; font-weight:600; padding:20px;">‚úÖ Tout semble correct !</div>';
            confirmBtn.textContent = "Exporter";
            confirmBtn.className = "btn-modal btn-confirm";
        } else {
            validation.issues.forEach(issue => {
                list.innerHTML += `<div class="validation-item error">${issue}</div>`;
            });
            validation.warnings.forEach(warning => {
                list.innerHTML += `<div class="validation-item">${warning}</div>`;
            });
            
            if (validation.issues.length > 0) {
                confirmBtn.textContent = "Exporter quand m√™me";
                confirmBtn.className = "btn-modal btn-force";
            } else {
                confirmBtn.textContent = "Exporter";
                confirmBtn.className = "btn-modal btn-confirm";
            }
        }
        
        modal.style.display = 'flex';
    }

    function closeValidation() {
        document.getElementById('validation-modal').style.display = 'none';
    }

    function exportAfterValidation() {
        closeValidation();
        document.querySelector('.btn-export').classList.add('exporting');
        setTimeout(() => {
            performExportWithDelay();
            document.querySelector('.btn-export').classList.remove('exporting');
        }, 500);
    }

    // ============================================================
    // üöÄ EXPORT AM√âLIOR√â
    // ============================================================

    function attemptExport() {
        const validation = validateQuiz();
        showValidation(validation);
    }

    function generateStudentTemplate(titre, devoirId, contentHTML, competences, blueprintData = null) {
        const compList = competences.map(c => `<li><span class="comp-tag">${c}</span></li>`).join('');
        const embeddedBlueprintScript = blueprintData ? `
<script>
    window.__PSE_BLUEPRINT = ${JSON.stringify(blueprintData, null, 2)};
<\/script>
        ` : '';

        
        return `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSE - ${titre}</title>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://firestore.googleapis.com" crossorigin>
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #f0f2f5 0%, #e8ecef 100%); 
            color: #1a1a2e; line-height: 1.6; padding: 12px; 
            min-height: 100vh;
        }
        .container { 
            max-width: 900px; margin: 0 auto; background: #fff; 
            border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.12); overflow: hidden; 
        }
        .header { 
            background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 50%, #74b9ff 100%); 
            color: #fff; padding: 32px 30px; text-align: center; 
            position: relative; overflow: hidden;
        }
        .header::before {
            content: ''; position: absolute; top: -50%; left: -50%;
            width: 200%; height: 200%; background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: headerShimmer 6s ease-in-out infinite;
        }
        @keyframes headerShimmer {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(180deg); }
        }
        .header h1 { font-size: 1.6em; margin-bottom: 6px; font-weight: 700; position: relative; z-index: 1; }
        .header .subtitle { font-size: 1.05em; opacity: 0.95; position: relative; z-index: 1; }
        
        .competences-box { 
            background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%); 
            border-left: 5px solid #6c5ce7; margin: 24px 28px; padding: 18px 22px; 
            border-radius: 0 10px 10px 0; box-shadow: 0 4px 15px rgba(108, 92, 231, 0.08);
        }
        .competences-box h3 { color: #6c5ce7; margin-bottom: 12px; font-size: 1em; font-weight: 600; }
        .competences-box ul { list-style: none; padding: 0; display:flex; gap:12px; flex-wrap:wrap; }
        .comp-tag { 
            display: inline-block; background: linear-gradient(135deg, #6c5ce7, #8b5cf6); 
            color: #fff; padding: 2px 12px; border-radius: 6px; font-weight: 600; 
            font-size: 0.8em; box-shadow: 0 2px 4px rgba(108, 92, 231, 0.2);
        }
        .body-content { padding: 0 28px 28px; }
        .identification { 
            background: linear-gradient(135deg, #fff3e0 0%, #fff8f1 100%); 
            border: 2px solid #ff9800; border-radius: 12px; padding: 18px 22px; 
            margin: 24px 0; box-shadow: 0 4px 12px rgba(255, 152, 0, 0.1);
        }
        .identification h3 { color: #e65100; margin-bottom: 12px; font-weight: 600; }
        .identification label { font-weight: 600; font-size: 0.9em; margin-right:12px; }
        .identification input { 
            padding: 10px 14px; border: 2px solid #ffcc80; border-radius: 8px; 
            font-size: 0.95em; width: 200px; text-transform: uppercase; 
            transition: all 0.2s ease; font-weight: 600;
        }
        .identification input:focus {
            border-color: #ff9800; outline: none; 
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .document-box { 
            background: linear-gradient(135deg, #fff8e1 0%, #fffbef 100%); 
            border: 1px solid #ffc107; border-radius: 10px; padding: 16px 20px; 
            margin: 16px 0; font-size: 0.9em; border-left: 6px solid #ffb74d; 
            box-shadow: 0 3px 10px rgba(255, 193, 7, 0.1);
        }
        .document-box h4 { 
            color: #f57f17; margin-bottom: 10px; font-size: 1.1em; 
            border-bottom: 2px solid #ffe0b2; padding-bottom: 6px; font-weight: 600;
        }

        .question-block { 
            background: linear-gradient(135deg, #fafbff 0%, #f8fafc 100%); 
            border: 2px solid #e2e8f0; border-radius: 12px; padding: 18px 20px; 
            margin: 16px 0; box-shadow: 0 4px 15px rgba(0,0,0,0.06);
            transition: all 0.2s ease;
        }
        .question-block:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        .q-label { 
            display: inline-block; background: linear-gradient(135deg, #6c5ce7, #8b5cf6); 
            color: #fff; width: 32px; height: 32px; line-height: 32px; text-align: center; 
            border-radius: 50%; font-size: 0.85em; font-weight: bold; margin-right: 10px; 
            box-shadow: 0 3px 8px rgba(108, 92, 231, 0.3);
        }
        .q-comp { 
            display: inline-block; background: linear-gradient(135deg, #e8eaf6, #f3e5f5); 
            color: #3949ab; padding: 3px 10px; border-radius: 6px; font-size: 0.75em; 
            font-weight: 600; margin-left: 8px; 
        }
        .q-points { 
            float: right; background: linear-gradient(135deg, #e0f7fa, #e1f5fe); 
            color: #006064; padding: 3px 12px; border-radius: 15px; font-size: 0.78em; 
            font-weight: 600; 
        }
        .q-text { 
            margin: 12px 0; font-size: 0.95em; font-weight: 500; color: #2c3e50; 
            line-height: 1.6;
        }
        
        .checkbox-group { display: flex; flex-direction: column; gap: 10px; margin-top: 12px; }
        .checkbox-group label { 
            display: flex; align-items: center; gap: 12px; padding: 12px 16px; 
            background: linear-gradient(135deg, #fff 0%, #fafafa 100%); 
            border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; 
            font-size: 0.9em; transition: all 0.2s ease;
        }
        .checkbox-group label:hover { 
            background: linear-gradient(135deg, #f3f0ff, #f8f5ff); 
            border-color: #a29bfe; transform: translateX(4px);
        }
        .checkbox-group input { width: 20px; height: 20px; accent-color: #6c5ce7; }
        
        .answer-input { 
            padding: 12px 16px; border: 3px solid #d1c4e9; border-radius: 8px; 
            font-size: 0.95em; width: 100%; max-width: 320px; 
            transition: all 0.2s ease; font-weight: 500;
            resize: none; overflow: hidden; min-height: 40px;
        }
        .answer-input:focus {
            border-color: #6c5ce7; outline: none;
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.1);
            transform: translateY(-1px);
        }
        .answer-select { 
            padding: 12px 16px; border: 3px solid #d1c4e9; border-radius: 8px; 
            font-size: 0.95em; background: #fff; width: 100%; font-weight: 500;
            transition: all 0.2s ease;
        }
        .answer-select:focus {
            border-color: #6c5ce7; outline: none;
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.1);
        }
        
        .eval-table { 
            width: 100%; border-collapse: collapse; font-size: 0.9em; 
            margin-top: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border-radius: 8px; overflow: hidden;
        }
        .eval-table td { 
            padding: 12px; border-bottom: 1px solid #f0f0f0; 
            background: linear-gradient(135deg, #fff 0%, #fafafa 100%);
        }
        
        .submit-section { text-align: center; margin: 40px 0; }
        .submit-btn { 
            background: linear-gradient(135deg, #6c5ce7, #a29bfe); color: #fff; 
            border: none; padding: 16px 48px; font-size: 1.1em; font-weight: 700; 
            border-radius: 50px; cursor: pointer; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            box-shadow: 0 8px 25px rgba(108, 92, 231, 0.3);
            position: relative; overflow: hidden;
        }
        .submit-btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        .submit-btn:hover::before { left: 100%; }
        .submit-btn:hover { 
            transform: translateY(-3px) scale(1.02); 
            box-shadow: 0 12px 35px rgba(108, 92, 231, 0.4); 
        }
        .submit-btn:disabled { 
            background: #bbb; cursor: not-allowed; transform: none; 
            box-shadow: none;
        }
        
        /* ANIMATIONS */
        .question-block { animation: slideInUp 0.5s ease-out; }
        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* RESPONSIVE */
        @media (max-width: 768px) {
            .body-content { padding: 0 16px 16px; }
            .competences-box { margin: 16px; }
            .identification { margin: 16px 0; padding: 16px; }
            .question-block { margin: 12px 0; padding: 16px; }
        }
    </style>
</head>
<body data-id-exercice="${devoirId}">
<div class="container">
    <div class="header">
        <h1>${titre}</h1>
        <div class="subtitle">Quiz Auto-Corrig√©</div>
    </div>
    <div class="competences-box">
        <h3>Comp√©tences √©valu√©es</h3>
        <ul>${compList}</ul>
    </div>
    <div class="body-content">

    <div class="identification">
        <h3>Identification</h3>
        <div>
            <label for="code-eleve">Code √©l√®ve :</label>
            <input type="text" id="code-eleve" class="reponse-eleve" data-qid="code_eleve" placeholder="Votre code">
        </div>
    </div>

    ${contentHTML}

    <div class="submit-section">
        <button class="submit-btn" id="btn-envoyer" onclick="window.tenterEnvoi()">Envoyer ma copie üì§</button>
        <p id="envoi-status" style="font-size:0.85em; color:#666; margin-top:12px;">Le syst√®me se charge...</p>
    </div>

    </div>
</div>

<script>
    const focus = { focusLeaves: 0, copyAttempts: 0 };
    function getAntiCheatOptions() {
        return (window.__PSE_BLUEPRINT && window.__PSE_BLUEPRINT.options) || { antiLeave: true, antiPaste: true, maxLeaves: 2 };
    }

    // Auto-resize pour les zones de texte
    function autoResize(el) {
        el.style.height = 'auto';
        el.style.height = el.scrollHeight + 'px';
    }

    // Appliquer l'auto-resize √† tous les champs texte
    document.addEventListener('DOMContentLoaded', function() {
        const textInputs = document.querySelectorAll('textarea, input[type="text"]');
        textInputs.forEach(input => {
            if (input.tagName === 'TEXTAREA') {
                input.addEventListener('input', () => autoResize(input));
                autoResize(input); // Taille initiale
            }
        });
    });

    document.addEventListener('visibilitychange', () => {
        const antiCheatOptions = getAntiCheatOptions();
        if (antiCheatOptions.antiLeave !== false && document.visibilityState === 'hidden') {
            focus.focusLeaves += 1;
        }
    });

    window.addEventListener('blur', () => {
        const antiCheatOptions = getAntiCheatOptions();
        if (antiCheatOptions.antiLeave !== false) {
            focus.focusLeaves += 1;
        }
    });

    document.addEventListener('copy', () => {
        focus.copyAttempts += 1;
    });

    document.addEventListener('paste', (event) => {
        const antiCheatOptions = getAntiCheatOptions();
        focus.copyAttempts += 1;
        if (antiCheatOptions.antiPaste !== false) {
            event.preventDefault();
        }
    });

    function ensureEmptyAnswerBindings() {
        const items = Array.isArray(window.__PSE_BLUEPRINT?.content) ? window.__PSE_BLUEPRINT.content : [];
        const expectedQids = items.map((item) => String(item?.qid || "").trim()).filter(Boolean);
        expectedQids.forEach((qid) => {
            const existingFallback = document.querySelector('input.reponse-eleve[type="hidden"][data-qid="' + qid + '"][data-fallback="1"]');
            const controls = Array.from(document.querySelectorAll('.reponse-eleve[data-qid="' + qid + '"]:not([data-fallback="1"])'));
            let answered = false;
            controls.forEach((el) => {
                const tag = (el.tagName || "").toUpperCase();
                const type = (el.type || "").toLowerCase();
                if (type === "radio" || type === "checkbox") {
                    if (el.checked) answered = true;
                } else if (tag === "SELECT") {
                    if ((el.value || "").trim() !== "") answered = true;
                } else if ((el.value || "").trim() !== "") {
                    answered = true;
                }
            });
            if (!answered && !existingFallback) {
                const fallback = document.createElement("input");
                fallback.type = "hidden";
                fallback.value = "";
                fallback.className = "reponse-eleve";
                fallback.setAttribute("data-qid", qid);
                fallback.setAttribute("data-fallback", "1");
                document.body.appendChild(fallback);
            }
            if (answered && existingFallback) {
                existingFallback.remove();
            }
        });
    }

    // Configuration Runner
    window.tenterEnvoi = async function() {
        const codeInput = document.getElementById('code-eleve');
        const code = (codeInput.value || '').trim().toUpperCase();
        if(!code || code.length < 2) { alert("Code √©l√®ve requis !"); return; }
        ensureEmptyAnswerBindings();
        
        const btn = document.getElementById('btn-envoyer');
        btn.disabled = true;
        btn.textContent = "Envoi en cours...";

        if (typeof window.envoyerCopie === 'function') {
            try {
                const classeLS = (localStorage.getItem('userClasse') || '').trim();
                const elevePayload = classeLS
                    ? { code: code, classe: classeLS, blueprintEmbedded: true, focus: focus }
                    : { code: code, blueprintEmbedded: true, focus: focus };
                await window.envoyerCopie(code, { external: 0 }, elevePayload);
                btn.textContent = "‚úÖ Envoy√© !";
                btn.style.background = "linear-gradient(135deg, #2ecc71, #27ae60)";
            } catch(e) {
                console.error(e);
                alert("Erreur: " + e.message);
                btn.disabled = false;
                btn.textContent = "R√©essayer";
            }
        } else {
            alert("Syst√®me non pr√™t. Rechargez la page.");
            btn.disabled = false;
        }
    };
<\/script>

${embeddedBlueprintScript}

<script type="module" src="https://mapse.fr/annuaire.js"><\/script>
<script type="module" src="https://mapse.fr/assets/pse-runner.js"><\/script>

<script>
    const statusEl = document.getElementById("envoi-status");
    statusEl.textContent = "Chargement des modules...";

    // V√©rification simple : si window.envoyerCopie existe, c'est charg√©
    const checkLoaded = setInterval(() => {
        if (window.envoyerCopie) {
            statusEl.textContent = "Syst√®me pr√™t.";
            statusEl.style.color = "green";
            console.log("Modules charg√©s avec succ√®s (m√©thode directe).");
            clearInterval(checkLoaded);
        }
    }, 500);

    // S√©curit√© au bout de 10 secondes
    setTimeout(() => {
        if (!window.envoyerCopie) {
            statusEl.textContent = "Si ce message persiste, v√©rifiez votre connexion ou contactez le support.";
            statusEl.style.color = "#d35400";
        }
    }, 10000);
<\/script>
</body>
</html>`;
    }

    // --- EXPORT TEMPLATE POUR IA ---
    function exportTemplate() {
        const questions = document.querySelectorAll('.question-block:not(.doc-block)');
        if (questions.length === 0) {
            alert("Cr√©ez d'abord au moins une question avant d'exporter le template.");
            return;
        }

        const devoirId = document.getElementById('devoir-id').value.trim() || `template_${Date.now()}`;
        const titre = document.getElementById('titre-devoir').value || "Template";
        const niveau = document.getElementById('niveau-cible').value || "Bac Pro";

        // Structure template avec instructions IA
        const template = {
            instructions: {
                mission: `Remplir ce devoir PSE niveau ${niveau} sur le th√®me : ${titre}`,
                regles_strictes: [
                    "RESPECTER exactement la structure JSON",
                    "NE JAMAIS modifier : id, qid, type, inputType, competence, bareme",
                    "GARDER tous les identifiants identiques",
                    "NE JAMAIS transformer une question vers un autre type",
                    "Niveau p√©dagogique : " + niveau,
                    "Utiliser le PDF cours fourni comme r√©f√©rence"
                ],
                autorisations: [
                    "Remplir uniquement : questionText, options[].label, reponseCorrecte, reponseAttendue, explication",
                    "Cr√©er des √©nonc√©s adapt√©s au niveau " + niveau,
                    "OBLIGATOIRE : R√©diger une correction compl√®te dans reponseAttendue",
                    "Corrections = explication p√©dagogique + justification + r√©f√©rence au cours",
                    "Exemple correction VF : 'Vrai. Le sommeil permet la r√©cup√©ration physique et mentale (cours p.15). Les phases de sommeil paradoxal consolident la m√©moire.'",
                    "R√©f√©rencer pr√©cis√©ment le cours : 'selon le document p.X', 'comme vu en cours chapitre Y'",
                    "Adapter les corrections au niveau " + niveau + " (vocabulaire, complexit√©)"
                ],
                formats_reponses: {
                    QCU: "1 seule bonne r√©ponse dans reponseCorrecte",
                    QCM: "Plusieurs bonnes r√©ponses possibles dans reponseCorrecte (tableau d'identifiants d'options)",
                    SELECT: "1 seule bonne r√©ponse dans reponseCorrecte (id value d'option)",
                    VF: "Justifier dans reponseAttendue pourquoi vrai ou faux + r√©f√©rence cours",
                    SHORT: "Accepter plusieurs formulations s√©par√©es par ; dans reponseCorrecte",
                    NUMBER: "Valeur num√©rique exacte + explication calcul dans reponseAttendue"
                },
                final: "SUPPRIMER ce champ instructions du JSON final"
            },
            id: devoirId,
            devoirId: devoirId,
            titre: titre + " [√Ä COMPL√âTER]",
            niveau: niveau,
            competences: [],
            version: "template_v1",
            autocorrect: true,
            content: []
        };

        const usedComps = new Set();
        let qCounter = 1;

        document.querySelectorAll('.question-block').forEach((block) => {
            const type = block.dataset.type;
            if (type === 'DOC') return; // Skip docs dans template

            const qidBase = block.dataset.qid;
            const competence = block.querySelector('.q-comp').value;
            const bareme = parseFloat(block.querySelector('.q-points').value) || 1;
            if (!isVisualWidgetType(type)) usedComps.add(competence);

            // Template selon type
            if (type === 'QCU' || type === 'SELECT' || type === 'QCM') {
                const optCount = block.querySelectorAll('.option-row').length || 4;
                const emptyOptions = Array.from({length: optCount}, (_, i) => ({
                    value: `${qidBase}_opt${i+1}`,
                    label: `[OPTION ${i+1} √Ä REMPLIR]`
                }));

                template.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: type === 'SELECT' ? "select" : "checkbox",
                    autocorrect: true,
                    questionText: "[√âNONC√â √Ä REMPLIR]",
                    reponseCorrecte: type === 'QCM' ? ["[ID_OPTION_1]", "[ID_OPTION_2]"] : "[ID_OPTION_CORRECTE]",
                    reponseAttendue: "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]",
                    explication: "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]",
                    options: emptyOptions
                });
                qCounter++;
            }
            else if (type === 'VF') {
                template.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: "vrai_faux",
                    autocorrect: true,
                    questionText: "[√âNONC√â √Ä REMPLIR]",
                    reponseCorrecte: "[vrai OU faux]",
                    reponseAttendue: "[JUSTIFICATION D√âTAILL√âE]",
                    explication: "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]"
                });
                qCounter++;
            }
            else if (type === 'SHORT' || type === 'NUMBER') {
                template.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: type === 'NUMBER' ? "number" : "texte_exact",
                    autocorrect: false,
                    besoinCorrectionManuelle: true,
                    questionText: "[√âNONC√â √Ä REMPLIR]",
                    reponseCorrecte: type === 'NUMBER' ? "[NOMBRE]" : ["[R√âPONSE1]", "[R√âPONSE2]"],
                    reponseAttendue: "[EXPLICATION AVEC CALCUL/JUSTIFICATION]",
                    explication: "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]",
                    tolerance: type === 'NUMBER' ? 0 : undefined
                });
                qCounter++;
            }
            else if (isEncType(type)) {
                const explanation = block.querySelector('.q-explain')?.value?.trim() || "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]";
                const activeRows = getActiveEncRows(block);
                if (activeRows.length === 0) return;
                const mode = String(block.querySelector('.enc-mode')?.value || "TEXT").toUpperCase();
                const rowPoints = splitPoints(bareme, Math.max(1, activeRows.length));
                activeRows.forEach((row, idx) => {
                    const subqid = row.dataset.subqid || `${qidBase}_${(getWidgetDef(type)?.slug || normalizeFrameKey(type))}_${row.dataset.subkey || idx + 1}`;
                    row.dataset.subqid = subqid;
                    const lineLabel = row.dataset.label || `Ligne ${idx + 1}`;
                    const opts = parseFrameOptions(row.querySelector(".enc-select-options")?.value || "");
                    const correct = String(row.querySelector(".enc-select-correct")?.value || "").trim();
                    const canAutocorrect = mode === "SELECT" && opts.length >= 2 && !!correct;
                    template.content.push({
                        type: "question",
                        qid: subqid,
                        label: `${qCounter}${String.fromCharCode(97 + idx)}`,
                        competence: competence,
                        bareme: rowPoints[idx] ?? 0,
                        inputType: mode === "SELECT" ? "select" : "texte_exact",
                        autocorrect: canAutocorrect,
                        besoinCorrectionManuelle: !canAutocorrect,
                        questionText: "[√âNONC√â √Ä REMPLIR] ‚Äî " + lineLabel,
                        reponseCorrecte: mode === "SELECT" ? "[ID_OPTION_CORRECTE]" : [],
                        reponseAttendue: explanation,
                        explication: explanation,
                        options: mode === "SELECT" ? (opts.length ? opts : [{ value: "opt1", label: "[OPTION 1]" }, { value: "opt2", label: "[OPTION 2]" }]) : undefined
                    });
                });
                qCounter++;
            }
        });

        template.competences = Array.from(usedComps).sort();

        // Export avec notification
        downloadFile(JSON.stringify(template, null, 4), `${devoirId}_TEMPLATE.json`, 'application/json');
        showNotification(`üì§ Template IA export√© ! ${template.content.length} questions √† remplir`, 'info');
    }
    function saveDraftJSON() {
        const titre = document.getElementById('titre-devoir').value || "";
        const devoirId = document.getElementById('devoir-id').value || "";
        const niveau = document.getElementById('niveau-cible').value || "";

        const questions = [];
        document.querySelectorAll('.question-block').forEach((block) => {
            const type = block.dataset.type;
            const item = {
                type: type,
                qid: block.dataset.qid || ""
            };

            if (type === 'DOC') {
                item.docTitle = block.querySelector('.doc-title-input')?.value || "";
                item.docContent = block.querySelector('.doc-content')?.value || "";
                questions.push(item);
                return;
            }

            item.enonce = block.querySelector('.q-enonce')?.value || "";
            item.competence = block.querySelector('.q-comp')?.value || "C1";
            item.points = parseFloat(block.querySelector('.q-points')?.value) || 0;
            item.explanation = block.querySelector('.q-explain')?.value || "";

            if (type === 'QCU' || type === 'SELECT' || type === 'QCM') {
                item.options = [];
                block.querySelectorAll('.option-row').forEach((row) => {
                    item.options.push({
                        text: row.querySelector('.opt-text')?.value || "",
                        correct: !!row.querySelector('.correct-check')?.checked
                    });
                });
            } else if (type === 'VF') {
                item.correct = block.querySelector('input[value="vrai"]')?.checked ? 'vrai' : 'faux';
            } else if (type === 'SHORT' || type === 'NUMBER') {
                item.validAnswers = block.querySelector('.valid-answers')?.value || "";
            } else if (type === 'BOX_NOTE') {
                item.noteContent = block.querySelector('.box-note-content')?.value || "";
            } else if (type === 'IMAGE') {
                item.imagePath = block.querySelector('.image-path-input')?.value || "";
            } else if (type === 'SEPARATOR' || type === 'TITLE') {
                // Pas de donn√©es suppl√©mentaires
            } else if (isEncType(type)) {
                item.titreEncadre = item.enonce;
                item.mode = String(block.querySelector('.enc-mode')?.value || 'TEXT').toUpperCase();
                item.lignes = getEncRows(block).map((row) => ({
                    label: row.dataset.label || "",
                    subkey: row.dataset.subkey || "",
                    subqid: row.dataset.subqid || createStableQid(),
                    enabled: row.dataset.enabled !== "0",
                    preview: row.querySelector('.enc-expected')?.value || "",
                    selectOptions: row.querySelector('.enc-select-options')?.value || "",
                    selectCorrect: row.querySelector('.enc-select-correct')?.value || ""
                }));
            }

            questions.push(item);
        });

        const draft = {
            meta: {
                titre,
                devoirId,
                niveau,
                dateISO: new Date().toISOString(),
                version: "master-quiz-auto"
            },
            questions,
            options: {}
        };

        const safeId = String(devoirId || "").trim();
        const fileName = safeId ? `${safeId}__draft.json` : `draft__${Date.now()}.json`;
        downloadFile(JSON.stringify(draft, null, 2), fileName, 'application/json');
        showNotification(`üíæ Brouillon sauvegard√© (${questions.length} blocs)`, 'info');
    }

    function restoreDraftJSON(data) {
        if (!data || !Array.isArray(data.questions)) {
            throw new Error("Format draft invalide");
        }

        const meta = data.meta || {};
        document.getElementById('titre-devoir').value = meta.titre || data.titre || "";
        document.getElementById('devoir-id').value = meta.devoirId || data.devoirId || "";
        document.getElementById('niveau-cible').value = meta.niveau || data.niveau || "";
        document.getElementById('quiz-content').innerHTML = '';
        qCount = 0;

        data.questions.forEach((q) => {
            const type = q.type || 'SHORT';

            if (type === 'DOC') {
                const contentDiv = createBlockSkeleton('DOC', null);
                const block = contentDiv.closest('.question-block');
                if (q.qid) block.dataset.qid = q.qid;
                safeSetValue(block.querySelector('.doc-title-input'), q.docTitle || "");
                safeSetValue(block.querySelector('.doc-content'), q.docContent || "");
                return;
            }

            addBlock(type, null);
            const blocks = document.querySelectorAll('.question-block:not(.doc-block)');
            const block = blocks[blocks.length - 1];
            if (!block) return;
            if (q.qid) block.dataset.qid = q.qid;

            safeSetValue(block.querySelector('.q-enonce'), q.enonce || "");
            safeSetValue(block.querySelector('.q-comp'), q.competence || "C1");
            safeSetValue(block.querySelector('.q-points'), q.points ?? 0);
            safeSetValue(block.querySelector('.q-explain'), q.explanation || "");

            if (type === 'QCU' || type === 'SELECT' || type === 'QCM') {
                const container = block.querySelector('div[id^="opts_"]');
                if (container) {
                    container.innerHTML = '';
                    const opts = Array.isArray(q.options) ? q.options : [];
                    (opts.length ? opts : [{ text: "", correct: false }, { text: "", correct: false }]).forEach((opt) => {
                        addOption(container.id, type === "QCM" ? "multi" : "single");
                        const rows = container.querySelectorAll('.option-row');
                        const row = rows[rows.length - 1];
                        safeSetValue(row.querySelector('.opt-text'), opt.text || "");
                        const ck = row.querySelector('.correct-check');
                        if (ck) ck.checked = !!opt.correct;
                    });
                }
            } else if (type === 'VF') {
                const v = (q.correct || '').toString().toLowerCase();
                const isVrai = v === 'vrai' || v === 'true' || v === 'v';
                const vraiEl = block.querySelector('input[value="vrai"]');
                const fauxEl = block.querySelector('input[value="faux"]');
                if (vraiEl) vraiEl.checked = isVrai;
                if (fauxEl) fauxEl.checked = !isVrai;
            } else if (type === 'SHORT' || type === 'NUMBER') {
                safeSetValue(block.querySelector('.valid-answers'), q.validAnswers || "");
            } else if (type === 'BOX_NOTE') {
                safeSetValue(block.querySelector('.box-note-content'), q.noteContent || "");
            } else if (type === 'IMAGE') {
                const input = block.querySelector('.image-path-input');
                safeSetValue(input, q.imagePath || "");
                if (input) updateImagePreview(input);
            } else if (type === 'SEPARATOR' || type === 'TITLE') {
                // Rien de sp√©cifique
            } else if (isEncType(type)) {
                const rows = getEncRows(block);
                const savedRows = Array.isArray(q.lignes) ? q.lignes : [];
                setEncMode(block, q.mode || "TEXT");
                if (savedRows.length === 0) {
                    rows.forEach((row) => setEncRowEnabled(row, true));
                    return;
                }
                rows.forEach((row) => setEncRowEnabled(row, false));
                savedRows.forEach((line) => {
                    const row = rows.find((r) => normalizeEncLabel(r.dataset.label) === normalizeEncLabel(line.label));
                    if (!row) return;
                    row.dataset.subqid = line.subqid || row.dataset.subqid || createStableQid();
                    row.dataset.subkey = line.subkey || row.dataset.subkey || normalizeFrameKey(line.label);
                    setEncRowEnabled(row, line.enabled !== false);
                    safeSetValue(row.querySelector('.enc-expected'), line.preview || "");
                    safeSetValue(row.querySelector('.enc-select-options'), line.selectOptions || "");
                    safeSetValue(row.querySelector('.enc-select-correct'), line.selectCorrect || "");
                });
            }
        });

        renumberQuestions();
        updateStats();
        document.getElementById('empty-msg').style.display = document.querySelectorAll('.question-block').length ? 'none' : 'block';
    }


    // ============================================================
    // üì• IMPORT JSON CORRIG√â (VERSION ROBUSTE)
    // ============================================================

    function sanitizeImportedJSONText(rawText) {
        let text = (rawText || "").toString();
        text = text.replace(/^\uFEFF/, "").trim();
        text = text.replace(/^\s*```(?:json)?\s*/i, "");
        text = text.replace(/\s*```\s*$/i, "");
        text = text.replace(/\[cite_start\]/gi, "");
        text = text.replace(/[‚Äú‚Äù]/g, '"').replace(/[‚Äò‚Äô]/g, "'");
        return text.trim();
    }

    function parseImportedJSON(rawText) {
        const base = sanitizeImportedJSONText(rawText);
        const attempts = [
            base,
            base.replace(/,\s*([}\]])/g, "$1"),
            base.replace(/^\s*\/\/.*$/gm, "").replace(/\/\*[\s\S]*?\*\//g, "")
        ];
        let lastError = null;
        for (const candidate of attempts) {
            try {
                return JSON.parse(candidate);
            } catch (err) {
                lastError = err;
            }
        }
        throw new Error(`JSON invalide (${lastError ? lastError.message : "erreur inconnue"}). V√©rifie les cl√©s non-quot√©es et les marqueurs IA.`);
    }

    function processImportedData(data) {
        if (!confirm("‚ö†Ô∏è ATTENTION : Tout le questionnaire actuel sera effac√© et remplac√© par le contenu import√©.\n\nContinuer ?")) {
            return;
        }

        const isDraftJSON = Array.isArray(data.questions) && data.meta && data.meta.version === "master-quiz-auto";
        if (isDraftJSON) {
            restoreDraftJSON(data);
            showNotification("‚úÖ Draft import√© avec succ√®s", "success");
            return;
        }

        if (!data.content || !Array.isArray(data.content)) {
            throw new Error("Format JSON invalide: content[] manquant.");
        }

        document.getElementById("quiz-content").innerHTML = "";
        qCount = 0;
        document.getElementById("titre-devoir").value = (data.titre || "").replace(" [√Ä COMPL√âTER]", "");
        document.getElementById("devoir-id").value = data.devoirId || "";
        document.getElementById("niveau-cible").value = data.niveau || "Bac Pro";
        showNotification("üîÑ Reconstruction en cours...", "info");

        setTimeout(() => {
            reconstructFromJSON(data);
            showNotification("‚úÖ Import r√©ussi ! " + document.querySelectorAll(".question-block").length + " questions r√©cup√©r√©es.", "success");
            updateStats();
        }, 200);
    }

    function importJSONFromPaste() {
        const overlay = document.createElement("div");
        overlay.style.cssText = "position:fixed;inset:0;background:rgba(15,23,42,.65);z-index:4000;display:flex;align-items:center;justify-content:center;padding:20px;";
        overlay.innerHTML = `
            <div style="width:min(900px,96vw);max-height:90vh;background:#fff;border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.35);display:flex;flex-direction:column;overflow:hidden;">
                <div style="padding:14px 18px;border-bottom:1px solid #e2e8f0;font-weight:700;color:#0f172a;">Coller un JSON (Template IA / Blueprint / Draft)</div>
                <textarea id="json-paste-area" style="min-height:360px;resize:vertical;border:none;outline:none;padding:14px 16px;font-family:ui-monospace,Menlo,Monaco,Consolas,monospace;font-size:13px;line-height:1.45;" placeholder='Colle ici le JSON brut...'></textarea>
                <div style="padding:12px 16px;border-top:1px solid #e2e8f0;display:flex;justify-content:flex-end;gap:10px;">
                    <button id="json-paste-cancel" style="border:1px solid #cbd5e1;background:#fff;border-radius:8px;padding:9px 14px;cursor:pointer;">Annuler</button>
                    <button id="json-paste-import" style="border:1px solid #0369a1;background:#0284c7;color:#fff;border-radius:8px;padding:9px 14px;cursor:pointer;font-weight:700;">Importer</button>
                </div>
            </div>
        `;
        document.body.appendChild(overlay);

        const close = () => overlay.remove();
        overlay.querySelector("#json-paste-cancel").onclick = close;
        overlay.onclick = (e) => { if (e.target === overlay) close(); };
        overlay.querySelector("#json-paste-import").onclick = () => {
            try {
                const raw = overlay.querySelector("#json-paste-area").value || "";
                const data = parseImportedJSON(raw);
                close();
                processImportedData(data);
            } catch (error) {
                alert(`Erreur import: ${error.message}`);
                console.error(error);
            }
        };
    }

    function importJSON() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json,text/plain';
        input.onchange = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = parseImportedJSON(e.target.result);
                    processImportedData(data);
                } catch (error) {
                    alert(`Erreur import: ${error.message}`);
                    console.error(error);
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    function reconstructFromJSON(data) {
        console.log("üîÑ D√©but reconstruction BLIND√âE...", data);
        const items = Array.isArray(data.content) ? data.content : [];
        const encGroups = {};
        const singles = [];

        items.forEach((item, idx) => {
            const qText = getFlexibleText(item, ['questionText', 'question', 'text', 'enonce', 'titre']);
            const match = qText.match(/^(.*)\s+‚Äî\s+(.+)$/);
            if (!match) {
                singles.push({ item, idx });
                return;
            }

            const titlePart = match[1].trim();
            const linePart = match[2].trim();
            const encType = getEncTypeFromLabel(linePart);
            if (!encType) {
                singles.push({ item, idx });
                return;
            }

            const comp = item.competence || item.comp || "C1";
            const groupKey = `${encType}|||${titlePart}|||${comp}`;
            if (!encGroups[groupKey]) {
                encGroups[groupKey] = { encType, title: titlePart, competence: comp, rows: [] };
            }
            encGroups[groupKey].rows.push({ item, label: linePart, idx });
        });

        Object.values(encGroups).forEach((group) => {
            addBlock(group.encType, null);
            const blocks = document.querySelectorAll('.question-block:not(.doc-block)');
            const block = blocks[blocks.length - 1];
            if (!block) return;

            const widgetDef = getWidgetDef(group.encType);
            const imported = widgetDef && typeof widgetDef.importFromBlueprint === "function"
                ? widgetDef.importFromBlueprint(group.rows.map((r) => r.item))
                : null;

            safeSetValue(block.querySelector('.q-enonce'), imported?.enonce || group.title);
            safeSetValue(block.querySelector('.q-comp'), imported?.competence || group.competence);
            const totalPoints = imported?.points ?? group.rows.reduce((sum, r) => sum + (parseFloat(r.item.bareme || r.item.points || 0) || 0), 0);
            safeSetValue(block.querySelector('.q-points'), Number(totalPoints.toFixed(2)));
            const firstExp = imported?.explanation || getFlexibleText(group.rows[0]?.item, ['reponseAttendue', 'explication', 'correction', 'justification']);
            safeSetValue(block.querySelector('.q-explain'), firstExp);

            const rowMap = new Map(getEncRows(block).map((r) => [normalizeEncLabel(r.dataset.label), r]));
            getEncRows(block).forEach((row) => setEncRowEnabled(row, false));
            const sourceRows = Array.isArray(imported?.lignes) ? imported.lignes : group.rows.map((entry) => ({
                label: entry.label,
                subqid: entry.item.qid,
                enabled: true,
                preview: Array.isArray(entry.item.reponseCorrecte) ? entry.item.reponseCorrecte.join("; ") : String(entry.item.reponseCorrecte || "")
            }));
            sourceRows.forEach((entry) => {
                const row = rowMap.get(normalizeEncLabel(entry.label));
                if (!row) return;
                row.dataset.subqid = entry.subqid || row.dataset.subqid || createStableQid();
                setEncRowEnabled(row, entry.enabled !== false);
                safeSetValue(row.querySelector('.enc-expected'), entry.preview || "");
            });
        });

        singles.forEach(({ item, idx }) => {
            const inType = (item.inputType || "").toLowerCase();
            if (typeof item.autocorrect === "undefined") {
                if (inType === "select" || inType === "checkbox" || inType === "vrai_faux") {
                    item.autocorrect = true;
                } else {
                    item.autocorrect = false;
                }
            }
            let type = "SHORT";

            if (inType === "checkbox") {
                const rawCorrect = item.reponseCorrecte ?? item.correct ?? item.answer;
                const asArray = Array.isArray(rawCorrect)
                    ? rawCorrect.filter(Boolean)
                    : String(rawCorrect || "").split(";").map((s) => s.trim()).filter(Boolean);
                type = asArray.length > 1 ? "QCM" : "QCU";
            }
            else if (inType === "select") type = "SELECT";
            else if (inType === "vrai_faux") type = "VF";
            else if (inType === "number") type = "NUMBER";
            else if (inType === "texte_exact" || inType === "short") type = "SHORT";

            const contentDiv = createBlockSkeleton(type, null);
            const block = contentDiv.closest('.question-block');
            const qid = item.qid || `imp_${Date.now()}_${idx}`;
            block.dataset.qid = qid;

            safeSetValue(block.querySelector('.q-comp'), item.competence || item.comp || "C1");
            safeSetValue(block.querySelector('.q-points'), parseFloat(item.bareme || item.points || 1) || 1);
            safeSetValue(block.querySelector('.q-enonce'), getFlexibleText(item, ['questionText', 'question', 'text', 'enonce', 'titre']));

            if (type === "QCU" || type === "SELECT" || type === "QCM") {
                const containerId = `auto_${Date.now()}_${idx}`;
                contentDiv.innerHTML = `
                    <div class="config-zone">
                        <span class="config-label">üìù Options import√©es (${type === "SELECT" ? "liste d√©roulante" : type})</span>
                        <div id="${containerId}"></div>
                        <button onclick="addOption('${containerId}', '${type === "QCM" ? "multi" : "single"}')" style="margin-top:10px;font-size:0.85em;cursor:pointer;background:#eee;border:none;padding:5px 10px;border-radius:4px;">+ Ajouter option</button>
                    </div>
                `;

                const opts = Array.isArray(item.options) ? item.options : [];
                const correctSet = new Set(
                    (Array.isArray(item.reponseCorrecte)
                        ? item.reponseCorrecte
                        : String(item.reponseCorrecte ?? item.correct ?? item.answer || "").split(";")
                    ).map((s) => String(s || "").trim()).filter(Boolean)
                );

                if (opts.length === 0) {
                    addOption(containerId, type === "QCM" ? "multi" : "single");
                    addOption(containerId, type === "QCM" ? "multi" : "single");
                } else {
                    opts.forEach((opt) => {
                        addOption(containerId, type === "QCM" ? "multi" : "single");
                        const rows = document.getElementById(containerId).querySelectorAll('.option-row');
                        const row = rows[rows.length - 1];
                        const optValue = String(opt?.value ?? opt?.id ?? "");
                        const optLabel = getFlexibleText(opt, ['label', 'text', 'value', 'option']);
                        safeSetValue(row.querySelector('.opt-text'), optLabel);
                        const ck = row.querySelector('.correct-check');
                        if (ck) ck.checked = correctSet.has(optValue);
                    });
                }

                addExplanationSecure(contentDiv, getFlexibleText(item, ['reponseAttendue', 'explication', 'correction', 'justification']));
            } else if (type === "VF") {
                const uid = Date.now() + Math.floor(Math.random() * 10000);
                const rep = String(item.reponseCorrecte ?? item.correct ?? "").toLowerCase();
                const isVrai = rep === 'vrai' || rep === 'true' || rep === 'v';
                contentDiv.innerHTML = `
                    <div class="config-zone" style="background:linear-gradient(135deg, #e8f5e9 0%, #f0fdf4 100%); border-color:#86efac;">
                        <span class="config-label" style="color:#15803d;">üéØ R√©ponse attendue</span>
                        <label style="margin-right:20px;font-weight:bold;color:#15803d;"><input type="radio" name="vf_${uid}" value="vrai" ${isVrai ? 'checked' : ''}> Vrai</label>
                        <label style="font-weight:bold;color:#dc2626;"><input type="radio" name="vf_${uid}" value="faux" ${!isVrai ? 'checked' : ''}> Faux</label>
                    </div>
                `;
                addExplanationSecure(contentDiv, getFlexibleText(item, ['reponseAttendue', 'explication', 'correction', 'justification']));
            } else if (type === "SHORT" || type === "NUMBER") {
                const raw = item.reponseCorrecte ?? item.correct ?? item.answer ?? "";
                const rep = Array.isArray(raw) ? raw.join('; ') : String(raw ?? "");
                contentDiv.innerHTML = `
                    <div class="config-zone">
                        <span class="config-label">üéØ R√©ponse attendue</span>
                        <textarea class="valid-answers auto-grow" rows="1" style="border:2px solid #22c55e; font-family:monospace; font-weight:bold; color:#15803d; width:100%;"></textarea>
                    </div>
                `;
                safeSetValue(contentDiv.querySelector('.valid-answers'), rep);
                addExplanationSecure(contentDiv, getFlexibleText(item, ['reponseAttendue', 'explication', 'correction', 'justification']));
            }
        });
        
        document.getElementById('empty-msg').style.display = 'none';
        console.log("‚úÖ Reconstruction termin√©e");
    }

    // === FONCTIONS UTILITAIRES BLIND√âES ===

    function getFlexibleText(item, fieldNames) {
        if (!item) return "";
        
        for (const field of fieldNames) {
            const value = item[field];
            if (value && typeof value === 'string' && value.trim()) {
                return value.trim();
            }
        }
        return "";
    }

    function safeSetValue(element, value) {
        if (!element) return;
        if (!value && value !== 0) value = "";
        
        try {
            element.value = String(value);
            if (element.classList.contains('auto-grow')) {
                autoResize(element);
            }
        } catch(e) {
            console.warn("Erreur injection texte:", e);
            element.value = "Erreur encodage";
        }
    }

    function addExplanationSecure(container, text) {
        const div = document.createElement('div');
        div.style.marginTop = "15px";
        div.innerHTML = `<textarea class="q-explain auto-grow" rows="1" placeholder="üí° Explication..." style="font-size:0.9em;color:#64748b;background:#f8fafc;border:2px dashed #cbd5e0;width:100%;border-radius:6px;padding:10px;"></textarea>`;
        container.appendChild(div);
        
        // INJECTION S√âCURIS√âE
        const textarea = div.querySelector('textarea');
        safeSetValue(textarea, text || "");
    }

    // --- SYSTEME NOTIFICATION ---
    function showNotification(message, type = 'success') {
        // Supprimer notification existante
        const existing = document.querySelector('.notification');
        if (existing) existing.remove();
        
        const notif = document.createElement('div');
        notif.className = `notification ${type}`;
        notif.textContent = message;
        document.body.appendChild(notif);
        
        // Animation d'apparition
        setTimeout(() => notif.classList.add('show'), 100);
        
        // Auto-suppression apr√®s 4 secondes
        setTimeout(() => {
            notif.classList.remove('show');
            setTimeout(() => notif.remove(), 300);
        }, 4000);
    }

    function downloadFile(content, filename, contentType) {
        const a = document.createElement('a');
        const file = new Blob([content], {type: contentType});
        a.href = URL.createObjectURL(file);
        a.download = filename;
        a.click();
    }

    function showExportErrors(title, errors) {
        if (!errors || errors.length === 0) return;
        const lines = errors.map((e, i) => `${i + 1}. ${e}`).join('\n');
        alert(`${title}\n\n${lines}`);
    }

    function assertAnswerBindings({ phase = "pre-export", expected = [], studentHtml = "" } = {}) {
        const errors = [];

        if (phase === "pre-export") {
            const qidSet = new Set();
            const subqidSet = new Set();
            const blocks = Array.from(document.querySelectorAll('.question-block'));
            blocks.forEach((block, index) => {
                const type = block.dataset.type;
                if (type === "DOC" || isNonExportWidgetType(type)) return;

                const qid = String(block.dataset.qid || "").trim();
                if (!qid) {
                    errors.push(`Bloc #${index + 1} (${type}) : qid principal manquant.`);
                } else if (qidSet.has(qid)) {
                    errors.push(`Bloc #${index + 1} (${type}) : qid dupliqu√© (${qid}).`);
                } else {
                    qidSet.add(qid);
                }

                if (isEncType(type)) {
                    const enonce = String(block.querySelector('.q-enonce')?.value || "").trim();
                    const points = parseFloat(block.querySelector('.q-points')?.value) || 0;
                    const activeRows = getActiveEncRows(block);
                    if (!enonce) errors.push(`Encadr√© #${index + 1} : √©nonc√© manquant.`);
                    if (points <= 0) errors.push(`Encadr√© #${index + 1} : bar√®me invalide (${points}).`);
                    if (!activeRows.length) errors.push(`Encadr√© #${index + 1} : aucune ligne active.`);
                    activeRows.forEach((row, ridx) => {
                        const subqid = String(row.dataset.subqid || "").trim();
                        if (!subqid) {
                            errors.push(`Encadr√© #${index + 1}, ligne ${ridx + 1} : subqid manquant.`);
                            return;
                        }
                        if (qidSet.has(subqid) || subqidSet.has(subqid)) {
                            errors.push(`Encadr√© #${index + 1}, ligne ${ridx + 1} : subqid dupliqu√© (${subqid}).`);
                            return;
                        }
                        subqidSet.add(subqid);
                    });
                }
            });
            return { ok: errors.length === 0, errors };
        }

        if (phase === "student-html") {
            const parser = new DOMParser();
            const doc = parser.parseFromString(`<div id="student-root">${studentHtml || ""}</div>`, "text/html");
            const root = doc.querySelector("#student-root");
            const controls = Array.from(root.querySelectorAll(".reponse-eleve"));
            controls.forEach((el, idx) => {
                const qid = String(el.getAttribute("data-qid") || "").trim();
                if (!qid) errors.push(`Champ √©l√®ve #${idx + 1} : data-qid manquant.`);
            });

            const expectedMap = new Map();
            expected.forEach((entry) => {
                const qid = String(entry.qid || "").trim();
                const answerType = entry.answerType;
                if (!qid) {
                    errors.push("Question export√©e sans qid (mapping √©l√®ve).");
                    return;
                }
                if (expectedMap.has(qid)) {
                    errors.push(`QID export√© dupliqu√© (${qid}).`);
                    return;
                }
                expectedMap.set(qid, answerType);
            });

            expectedMap.forEach((answerType, qid) => {
                if (answerType === "QCU" || answerType === "VF") {
                    const radios = Array.from(root.querySelectorAll(`input[type="radio"].reponse-eleve[data-qid="${qid}"]`));
                    if (radios.length < 2) {
                        errors.push(`${answerType} (${qid}) : radios manquantes c√¥t√© √©l√®ve.`);
                        return;
                    }
                    radios.forEach((radio) => {
                        if (radio.getAttribute("name") !== qid) {
                            errors.push(`${answerType} (${qid}) : name radio invalide (${radio.getAttribute("name") || "vide"}).`);
                        }
                    });
                } else if (answerType === "QCM") {
                    const checks = Array.from(root.querySelectorAll(`input[type="checkbox"].reponse-eleve[data-qid="${qid}"]`));
                    if (checks.length < 2) {
                        errors.push(`QCM (${qid}) : checkboxes manquantes c√¥t√© √©l√®ve.`);
                        return;
                    }
                    checks.forEach((chk) => {
                        if (chk.getAttribute("name") !== qid) {
                            errors.push(`QCM (${qid}) : name checkbox invalide (${chk.getAttribute("name") || "vide"}).`);
                        }
                    });
                } else if (answerType === "SELECT") {
                    const selects = root.querySelectorAll(`select.reponse-eleve[data-qid="${qid}"]`);
                    if (selects.length !== 1) {
                        errors.push(`SELECT (${qid}) : attendu 1 <select>, trouv√© ${selects.length}.`);
                    }
                } else {
                    const matches = root.querySelectorAll(`.reponse-eleve[data-qid="${qid}"]`);
                    if (matches.length !== 1) {
                        errors.push(`Question ouverte (${qid}) : attendu 1 champ r√©ponse, trouv√© ${matches.length}.`);
                    }
                }
            });

            controls.forEach((el) => {
                const qid = String(el.getAttribute("data-qid") || "").trim();
                if (qid === "code_eleve") return;
                if (!expectedMap.has(qid)) {
                    errors.push(`Champ √©l√®ve avec data-qid non reconnu (${qid}).`);
                }
            });
            return { ok: errors.length === 0, errors };
        }

        return { ok: true, errors };
    }

    // --- EXPORT AM√âLIOR√â AVEC ESPACEMENT ---
    function performExportWithDelay() {
        const devoirId = document.getElementById('devoir-id').value.trim() || `quiz_${Date.now()}`;
        const titre = document.getElementById('titre-devoir').value || "Devoir";
        const niveau = document.getElementById('niveau-cible').value || "Bac Pro";
        const preCheck = assertAnswerBindings({ phase: "pre-export" });
        if (!preCheck.ok) {
            showExportErrors("‚ùå Export bloqu√© : incoh√©rences qid d√©tect√©es", preCheck.errors);
            return;
        }

        if (!/^[A-Za-z0-9_-]+$/.test(devoirId)) {
            alert("ID unique invalide.\nUtilisez uniquement des lettres, chiffres, tirets (-) et underscores (_).");
            return;
        }

        const blueprint = {
            id: devoirId,
            devoirId: devoirId,
            titre: titre,
            niveau: niveau,
            competences: [],
            version: "v1",
            autocorrect: true,
            options: { antiLeave: true, antiPaste: true, maxLeaves: 2 },
            content: []
        };

        const usedComps = new Set();
        let studentHtmlQuestions = "";
        let qCounter = 1;
        const expectedAnswerBindings = [];
        const seenExportQids = new Set();
        const exportErrors = [];

        function trackExportQid(qid, contextLabel) {
            const clean = String(qid || "").trim();
            if (!clean) {
                exportErrors.push(`${contextLabel} : qid vide.`);
                return false;
            }
            if (seenExportQids.has(clean)) {
                exportErrors.push(`${contextLabel} : qid dupliqu√© (${clean}).`);
                return false;
            }
            seenExportQids.add(clean);
            return true;
        }

        document.querySelectorAll('.question-block').forEach((block) => {
            const type = block.dataset.type;

            if (type === 'DOC') {
                const docTitle = block.querySelector('.doc-title-input').value;
                const content = block.querySelector('.doc-content').value.replace(/\n/g, '<br>');
                studentHtmlQuestions += `
                    <div class="document-box">
                        <h4>${docTitle}</h4>
                        <p>${content}</p>
                    </div>
                `;
                return;
            }

            const qidBase = block.dataset.qid;
            const enoncePlain = block.querySelector('.q-enonce').value.trim();
            const enonce = enoncePlain.replace(/\n/g, '<br>');
            const bareme = parseFloat(block.querySelector('.q-points').value) || 1;
            const competence = block.querySelector('.q-comp').value;
            if (!isVisualWidgetType(type)) usedComps.add(competence);
            const widgetDef = getWidgetDef(type);

            if (isNonExportWidgetType(type)) {
                const visualHtml = renderWidgetBlock(type, block, { qCounter, qidBase, enoncePlain, enonceHtml: enonce, bareme, competence });
                if (visualHtml) studentHtmlQuestions += visualHtml;
                return;
            }

            if (widgetDef) {
                const ctx = { qCounter, qidBase, enoncePlain, enonceHtml: enonce, bareme, competence };
                let widgetItems = [];
                let widgetHtml = "";
                try {
                    if (typeof widgetDef.exportToBlueprint === "function") {
                        const out = widgetDef.exportToBlueprint(block, ctx);
                        if (Array.isArray(out)) widgetItems = out;
                    }
                    if (typeof widgetDef.exportToStudentHTML === "function") {
                        widgetHtml = widgetDef.exportToStudentHTML(block, ctx) || "";
                    }
                } catch (err) {
                    console.warn("Widget export error:", type, err);
                }

                if (widgetItems.length) blueprint.content.push(...widgetItems);
                widgetItems.forEach((item) => {
                    if (trackExportQid(item.qid, `Widget ${type}`)) {
                        const inType = String(item.inputType || "").toLowerCase();
                        const answerType = inType === "select" ? "SELECT"
                            : (inType === "checkbox" && Array.isArray(item.reponseCorrecte)) ? "QCM"
                            : (inType === "checkbox") ? "QCU"
                            : (inType === "vrai_faux") ? "VF"
                            : "OPEN";
                        expectedAnswerBindings.push({ qid: item.qid, answerType });
                    }
                });
                if (widgetHtml) studentHtmlQuestions += widgetHtml;
                if (widgetDef.countAsQuestion !== false && (widgetItems.length || widgetHtml)) {
                    qCounter++;
                }
                return;
            }

            if (type === 'QCU' || type === 'SELECT' || type === 'QCM') {
                let options = [];
                let correctVal = null;
                const correctVals = [];
                let correctText = "";
                const isQcm = type === "QCM";

                block.querySelectorAll('.option-row').forEach((row, idx) => {
                    const txt = row.querySelector('.opt-text').value.trim();
                    const val = `${qidBase}_opt${idx+1}`;
                    const isCorrect = row.querySelector('.correct-check').checked;
                    
                    if(txt) {
                        options.push({ value: val, label: txt });
                        if(isCorrect) {
                            if (isQcm) correctVals.push(val);
                            if (correctVal === null) {
                                correctVal = val;
                                correctText = txt;
                            }
                        }
                    }
                });

                // Utiliser l'explication personnalis√©e ou fallback sur r√©ponse basique
                const explanation = block.querySelector('.q-explain').value.trim();
                const finalExplanation = explanation || correctText;

                blueprint.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: type === "SELECT" ? "select" : "checkbox",
                    autocorrect: true,
                    questionText: enoncePlain,
                    reponseCorrecte: isQcm ? correctVals : correctVal,
                    reponseAttendue: finalExplanation,
                    options: options
                });
                trackExportQid(qidBase, type);
                expectedAnswerBindings.push({ qid: qidBase, answerType: type === "SELECT" ? "SELECT" : (isQcm ? "QCM" : "QCU") });

                if (type === "SELECT") {
                    const optsHtml = `<option value="">-- S√©lectionner --</option>` + options.map((opt) => `<option value="${opt.value}">${opt.label}</option>`).join("");
                    studentHtmlQuestions += `
                        <div class="question-block">
                            <span class="q-label">${qCounter}</span><span class="q-comp">${competence}</span><span class="q-points">${bareme} pts</span>
                            <div class="q-text">${enonce}</div>
                            <div><select class="reponse-eleve answer-select" data-qid="${qidBase}">${optsHtml}</select></div>
                        </div>
                    `;
                } else {
                    studentHtmlQuestions += `
                        <div class="question-block">
                            <span class="q-label">${qCounter}</span><span class="q-comp">${competence}</span><span class="q-points">${bareme} pts</span>
                            <div class="q-text">${enonce}</div>
                            <div class="checkbox-group">
                    `;
                    options.forEach(opt => {
                        const inputType = isQcm ? "checkbox" : "radio";
                        studentHtmlQuestions += `<label><input type="${inputType}" name="${qidBase}" value="${opt.value}" class="reponse-eleve" data-qid="${qidBase}"> ${opt.label}</label>`;
                    });
                    studentHtmlQuestions += `</div></div>`;
                }
                qCounter++;
            }
            else if (type === 'VF') {
                const isVrai = block.querySelector('input[value="vrai"]').checked;
                blueprint.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: "vrai_faux",
                    autocorrect: true,
                    questionText: enoncePlain,
                    reponseCorrecte: isVrai ? "vrai" : "faux",
                    reponseAttendue: isVrai ? "Vrai" : "Faux"
                });
                trackExportQid(qidBase, "VF");
                expectedAnswerBindings.push({ qid: qidBase, answerType: "VF" });

                studentHtmlQuestions += `
                    <div class="question-block">
                        <span class="q-label">${qCounter}</span><span class="q-comp">${competence}</span><span class="q-points">${bareme} pts</span>
                        <div class="q-text">${enonce}</div>
                        <div class="checkbox-group">
                            <label><input type="radio" name="${qidBase}" value="vrai" class="reponse-eleve" data-qid="${qidBase}"> Vrai</label>
                            <label><input type="radio" name="${qidBase}" value="faux" class="reponse-eleve" data-qid="${qidBase}"> Faux</label>
                        </div>
                    </div>
                `;
                qCounter++;
            }
            else if (type === 'SHORT' || type === 'NUMBER') {
                const rawVal = block.querySelector('.valid-answers').value;
                const accepted = rawVal.split(';').map(s => s.trim()).filter(s => s);
                const isNum = type === 'NUMBER';
                const shouldAutocorrect = false;

                blueprint.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: isNum ? "number" : "texte_exact",
                    autocorrect: shouldAutocorrect,
                    besoinCorrectionManuelle: shouldAutocorrect ? undefined : true,
                    questionText: enoncePlain,
                    reponseCorrecte: isNum ? (accepted.length ? parseFloat(accepted[0]) : null) : accepted,
                    reponseAttendue: accepted.join(" OU "),
                    tolerance: isNum ? 0 : undefined
                });
                trackExportQid(qidBase, type);
                expectedAnswerBindings.push({ qid: qidBase, answerType: "OPEN" });

                studentHtmlQuestions += `
                    <div class="question-block">
                        <span class="q-label">${qCounter}</span><span class="q-comp">${competence}</span><span class="q-points">${bareme} pts</span>
                        <div class="q-text">${enonce}</div>
                        <div><input type="${isNum?'number':'text'}" class="reponse-eleve answer-input" data-qid="${qidBase}" placeholder="Votre r√©ponse"></div>
                    </div>
                `;
                qCounter++;
            }
            else if (isEncType(type)) {
                const activeRows = getActiveEncRows(block);
                if (activeRows.length === 0) return;
                const explanation = block.querySelector('.q-explain')?.value?.trim() || "";
                const pointsPerRow = splitPoints(bareme, activeRows.length);

                studentHtmlQuestions += `
                    <div class="question-block">
                        <span class="q-label">${qCounter}</span><span class="q-comp">${competence}</span><span class="q-points">${bareme} pts</span>
                        <div class="q-text">${enonce}</div>
                        <div class="table-wrapper">
                            <table class="eval-table">
                                <tbody>
                `;

                activeRows.forEach((row, idx) => {
                    const lineLabel = row.dataset.label || `Ligne ${idx + 1}`;
                    const subqid = row.dataset.subqid || createStableQid();
                    row.dataset.subqid = subqid;
                    const subLabel = `${qCounter}${String.fromCharCode(97 + idx)}`;
                    blueprint.content.push({
                        type: "question",
                        qid: subqid,
                        label: subLabel,
                        competence: competence,
                        bareme: pointsPerRow[idx] ?? 0,
                        inputType: "texte_exact",
                        autocorrect: false,
                        besoinCorrectionManuelle: true,
                        questionText: `${enoncePlain} ‚Äî ${lineLabel}`,
                        reponseCorrecte: [],
                        reponseAttendue: explanation
                    });
                    trackExportQid(subqid, `${type} ligne ${idx + 1}`);
                    expectedAnswerBindings.push({ qid: subqid, answerType: "OPEN" });
                    studentHtmlQuestions += `
                        <tr>
                            <td>${lineLabel}</td>
                            <td><textarea class="reponse-eleve answer-input" data-qid="${subqid}" rows="2" style="width:100%; min-height:54px;" placeholder="Votre r√©ponse"></textarea></td>
                        </tr>
                    `;
                });

                studentHtmlQuestions += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
                qCounter++;
            }
        });

        if (exportErrors.length) {
            showExportErrors("‚ùå Export bloqu√© : erreurs d'identifiants", exportErrors);
            return;
        }

        const htmlCheck = assertAnswerBindings({
            phase: "student-html",
            expected: expectedAnswerBindings,
            studentHtml: studentHtmlQuestions
        });
        if (!htmlCheck.ok) {
            showExportErrors("‚ùå Export bloqu√© : structure r√©ponses √©l√®ve invalide", htmlCheck.errors);
            return;
        }

        blueprint.competences = Array.from(usedComps).sort();
        blueprint.autocorrect = true;
        blueprint.questions = blueprint.content;
        blueprint.items = blueprint.content;

        const finalStudentHTML = generateStudentTemplate(titre, devoirId, studentHtmlQuestions, blueprint.competences, blueprint);

        downloadFile(JSON.stringify(blueprint, null, 4), `${devoirId}_blueprint.json`, 'application/json');
        showNotification(`üìÑ Blueprint t√©l√©charg√© ! Fichier √©l√®ve dans 2 secondes...`, 'info');
        
        // 2. Export fichier √©l√®ve apr√®s 2 secondes
        setTimeout(() => {
            downloadFile(finalStudentHTML, `${devoirId}_eleve.html`, 'text/html');
            showNotification(`‚úÖ Export termin√© ! 2 fichiers t√©l√©charg√©s avec succ√®s`);
        }, 2000);
    }

    // Initialisation au chargement
    document.addEventListener('DOMContentLoaded', function() {
        try {
            if (window.MasterWidgets && typeof window.MasterWidgets.init === "function") {
                window.MasterWidgets.init();
            }
        } catch (err) {
            console.warn("MasterWidgets init error:", err);
        }
        renderWidgetButtons();
        updateStats();
    });
</script>
</body>
</html>
