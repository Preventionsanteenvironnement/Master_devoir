<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1.0" name="viewport">
<title>Master QUIZ AUTO - Final (Compatible Cockpit)</title>
<style>
    /* --- STYLE √âDITEUR AM√âLIOR√â --- */
    :root { 
        --primary: #3498db; --success: #27ae60; --danger: #e74c3c; --dark: #2c3e50; 
        --warning: #f39c12; --purple: #8b5cf6; --teal: #14b8a6; --orange: #f97316;
    }
    body { 
        font-family: 'Segoe UI', sans-serif; max-width: 950px; margin: 0 auto; 
        padding: 20px; background: #f4f7f6; color: #333; padding-bottom: 120px; 
        transition: all 0.2s ease;
    }
    
    .container { 
        background: white; padding: 30px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); 
        border-radius: 12px; transition: box-shadow 0.3s ease; 
    }
    .container:hover { box-shadow: 0 6px 25px rgba(0,0,0,0.12); }
    
    h1 { 
        color: var(--dark); text-align: center; border-bottom: 3px solid var(--primary); 
        padding-bottom: 15px; margin-top: 0; position: relative;
    }
    
    /* COMPTEUR TEMPS R√âEL */
    .quiz-stats { 
        position: absolute; top: -5px; right: 0; background: var(--primary); 
        color: white; padding: 4px 12px; border-radius: 15px; font-size: 0.75em; 
        font-weight: bold; transition: all 0.3s ease;
    }
    .quiz-stats:hover { background: var(--dark); }
    
    .header-inputs { 
        display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 15px; margin-bottom: 25px; 
        background: linear-gradient(135deg, #eef2f3 0%, #f8f9fa 100%); 
        padding: 18px; border-radius: 10px; border: 1px solid #e0e6ed;
    }
    .input-group label { 
        display: block; font-size: 0.85em; font-weight: 600; color: #5a6c7d; 
        margin-bottom: 6px; transition: color 0.2s;
    }
    input, select, textarea { 
        padding: 11px 14px; border: 2px solid #e1e8ed; border-radius: 6px; width: 100%; 
        box-sizing: border-box; font-family: inherit; transition: all 0.2s ease;
        background: #fff;
    }
    input:focus, select:focus, textarea:focus {
        outline: none; border-color: var(--primary); 
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        transform: translateY(-1px);
    }
    
    /* Auto-Resize pour les zones de texte */
    textarea.auto-grow { 
        resize: none; overflow: hidden; min-height: 40px; height: auto; 
        transition: border-color 0.2s, box-shadow 0.2s; 
    }
    textarea.auto-grow:focus { 
        border-color: var(--primary); background: #fbfcfd; 
        box-shadow: 0 2px 8px rgba(52, 152, 219, 0.08);
    }

    /* BLOCS QUESTIONS AM√âLIOR√âS */
    .question-block { 
        background: #fff; border: 1px solid #e2e8f0; border-left: 5px solid var(--primary); 
        margin-bottom: 20px; padding: 18px; position: relative; border-radius: 8px; 
        box-shadow: 0 2px 8px rgba(0,0,0,0.04); transition: all 0.2s ease;
    }
    .question-block:hover { 
        box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
        transform: translateY(-1px);
    }
    .doc-block { 
        border-left-color: var(--warning); background: #fffcf5; 
        border: 1px solid #fed7aa;
    }
    
    .q-header { 
        display: flex; align-items: flex-start; margin-bottom: 15px; 
        background: linear-gradient(135deg, #f8f9fa 0%, #f1f5f9 100%); 
        padding: 12px 15px; border-radius: 6px; border-bottom: 1px solid #e2e8f0; gap: 12px; 
    }
    .q-num { 
        background: var(--primary); color: white; width: 28px; height: 28px; 
        display: flex; align-items: center; justify-content: center; border-radius: 50%; 
        font-size: 0.85em; font-weight: bold; margin-top: 6px; flex-shrink: 0;
        transition: all 0.2s ease;
    }
    .q-num:hover { background: var(--dark); transform: scale(1.05); }
    .doc-block .q-num { background: var(--warning); }

    .q-enonce { 
        flex: 1; font-weight: 600; border: none; background: transparent; 
        border-bottom: 2px dashed #cbd5e0; font-size: 1.05em; padding: 8px 0;
    }
    .q-enonce:focus { 
        border-bottom: 2px solid var(--primary); background: rgba(255,255,255,0.9);
        box-shadow: 0 2px 4px rgba(52, 152, 219, 0.1);
    }

    .q-controls { 
        display: flex; align-items: center; gap: 8px; margin-left: auto; 
    }
    .q-controls select, .q-controls input {
        font-weight: 600; font-size: 0.9em;
    }
    .delete-btn { 
        background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); 
        color: var(--danger); border: 1px solid #fca5a5; padding: 6px 12px; 
        cursor: pointer; border-radius: 6px; font-weight: 600; white-space: nowrap; 
        transition: all 0.2s ease; font-size: 0.85em;
    }
    .delete-btn:hover { 
        background: var(--danger); color: white; 
        transform: translateY(-1px); box-shadow: 0 4px 8px rgba(231, 76, 60, 0.2);
    }

    /* ZONES CONFIG AM√âLIOR√âES */
    .config-zone { 
        background: linear-gradient(135deg, #f1f8ff 0%, #f0f9ff 100%); 
        padding: 15px; margin-top: 12px; border-radius: 8px; 
        border: 1px dashed #93c5fd; box-shadow: 0 2px 4px rgba(59, 130, 246, 0.05);
    }
    .config-label { 
        font-weight: 600; font-size: 0.9em; color: #1e40af; 
        display: block; margin-bottom: 10px; 
    }
    
    .option-row { 
        display: flex; align-items: flex-start; gap: 12px; margin-bottom: 10px; 
        padding: 8px; background: rgba(255,255,255,0.7); border-radius: 6px;
        transition: all 0.2s ease;
    }
    .option-row:hover { 
        background: rgba(255,255,255,0.9); 
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .enc-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
    }
    .enc-table th, .enc-table td {
        border: 1px solid #cbd5e1;
        padding: 10px;
        vertical-align: top;
    }
    .enc-table th {
        background: #eff6ff;
        text-align: left;
        color: #1e3a8a;
    }
    .enc-label-cell {
        width: 34%;
        font-weight: 700;
        color: #1e293b;
        background: #f8fafc;
    }
    .enc-answer-cell textarea {
        width: 100%;
        min-height: 56px;
    }
    .enc-row-disabled {
        opacity: 0.45;
    }
    .enc-row-disabled .enc-expected {
        pointer-events: none;
        background: #e2e8f0;
    }
    .enc-toggle-btn {
        border: 1px solid #94a3b8;
        background: #fff;
        border-radius: 6px;
        cursor: pointer;
        padding: 2px 8px;
        font-weight: 700;
        color: #334155;
    }
    .correct-check { 
        width: 22px; height: 22px; cursor: pointer; accent-color: var(--success); 
        margin-top: 8px; transition: transform 0.2s;
    }
    .correct-check:hover { transform: scale(1.1); }
    
    /* TOOLBAR AM√âLIOR√âE */
    .tools-panel { 
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); 
        display: flex; gap: 6px; z-index: 2000; 
        background: linear-gradient(135deg, rgba(30, 41, 59, 0.95) 0%, rgba(15, 23, 42, 0.95) 100%); 
        padding: 15px 20px; border-radius: 16px; 
        box-shadow: 0 12px 40px rgba(0,0,0,0.3), 0 4px 20px rgba(0,0,0,0.2); 
        backdrop-filter: blur(12px); flex-wrap: wrap; justify-content: center; 
        width: 90%; max-width: 900px; border: 1px solid rgba(255,255,255,0.1);
    }
    .btn-tool { 
        padding: 11px 18px; border-radius: 8px; border: none; cursor: pointer; 
        font-weight: 600; color: white; font-size: 13px; 
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
        display: flex; align-items: center; gap: 8px;
        position: relative; overflow: hidden;
    }
    .btn-tool::before {
        content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.5s;
    }
    .btn-tool:hover::before { left: 100%; }
    .btn-tool:hover { 
        transform: translateY(-2px) scale(1.02); 
        filter: brightness(1.15);
        box-shadow: 0 8px 20px rgba(0,0,0,0.2);
    }
    
    .btn-qcm { background: linear-gradient(135deg, #3b82f6, #1d4ed8); } 
    .btn-vf { background: linear-gradient(135deg, #8b5cf6, #7c3aed); } 
    .btn-text { background: linear-gradient(135deg, #f97316, #ea580c); } 
    .btn-match { background: linear-gradient(135deg, #14b8a6, #0f766e); } 
    .btn-doc { background: linear-gradient(135deg, #f39c12, #d97706); }
    .btn-export { 
        background: linear-gradient(135deg, #22c55e, #16a34a); 
        border: 1px solid #15803d; font-size: 14px; padding: 12px 28px; 
        box-shadow: 0 6px 12px rgba(34, 197, 94, 0.25);
        font-weight: 700;
    }
    
    .insert-btn { 
        background: linear-gradient(135deg, var(--warning), #d97706); color: white; 
        border: none; padding: 8px 14px; border-radius: 6px; font-size: 0.85em; 
        font-weight: 600; cursor: pointer; margin-top: 12px; 
        transition: all 0.2s ease;
    }
    .insert-btn:hover { 
        background: linear-gradient(135deg, #d97706, #b45309); 
        transform: translateY(-1px); 
    }

    /* MODAL VALIDATION */
    .validation-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.6); z-index: 3000; display: none;
        align-items: center; justify-content: center; backdrop-filter: blur(4px);
    }
    .validation-content {
        background: white; padding: 30px; border-radius: 16px; max-width: 500px;
        width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        animation: modalSlide 0.3s ease-out;
    }
    @keyframes modalSlide {
        from { transform: translateY(-50px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }
    .validation-content h3 {
        color: var(--primary); margin-bottom: 20px; font-size: 1.3em;
        text-align: center;
    }
    .validation-list {
        max-height: 300px; overflow-y: auto; margin-bottom: 20px;
    }
    .validation-item {
        padding: 10px 15px; margin: 8px 0; border-radius: 6px;
        border-left: 4px solid #fbbf24; background: #fffbeb;
        font-size: 0.9em;
    }
    .validation-item.error { border-left-color: var(--danger); background: #fef2f2; }
    .validation-buttons {
        display: flex; gap: 12px; justify-content: center;
    }
    .btn-modal {
        padding: 10px 20px; border-radius: 6px; border: none; cursor: pointer;
        font-weight: 600; transition: all 0.2s;
    }
    .btn-cancel { background: #f3f4f6; color: #374151; }
    .btn-cancel:hover { background: #e5e7eb; }
    .btn-confirm { background: var(--success); color: white; }
    .btn-confirm:hover { background: #16a34a; }
    .btn-force { background: var(--danger); color: white; }
    .btn-force:hover { background: #dc2626; }

    /* SYST√àME NOTIFICATION */
    .notification {
        position: fixed; top: 20px; right: 20px; z-index: 4000;
        background: linear-gradient(135deg, #22c55e, #16a34a); color: white;
        padding: 12px 20px; border-radius: 8px; font-weight: 600;
        box-shadow: 0 8px 25px rgba(34, 197, 94, 0.3);
        transform: translateX(400px); opacity: 0;
        transition: all 0.3s ease;
    }
    .notification.show {
        transform: translateX(0); opacity: 1;
    }
    .notification.info {
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
    }

    /* ANIMATIONS SUBTILES */
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    .exporting { animation: pulse 1.5s infinite; }
    
    @keyframes slideIn {
        from { transform: translateX(-20px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    .question-block { animation: slideIn 0.3s ease-out; }
</style>
<script src="master-widgets.js" defer></script>
</head>
<body>

<div class="container">
    <h1>G√©n√©rateur de Quiz Auto v3.0 (Corrig√©)
        <span class="quiz-stats" id="quiz-stats">0 question - 0 pts</span>
    </h1>
    
    <div class="header-inputs">
        <div class="input-group">
            <label>Titre du Devoir</label>
            <input type="text" id="titre-devoir" value="√âvaluation" placeholder="Titre..." onchange="updateStats()">
        </div>
        <div class="input-group">
            <label>ID Unique (Fichier)</label>
            <input type="text" id="devoir-id" value="quiz_01" placeholder="ex: quiz_chapitre1">
        </div>
        <div class="input-group">
            <label>Niveau / Classe</label>
            <input type="text" id="niveau-cible" value="Bac Pro">
        </div>
    </div>

    <div id="quiz-content"></div>
    
    <div id="empty-msg" style="text-align:center; padding:50px; color:#64748b; border:2px dashed #cbd5e0; border-radius:12px; background:linear-gradient(135deg, #f8fafc, #f1f5f9);">
        <div style="font-size:1.2em; margin-bottom:10px;">üìù</div>
        Aucune question. Utilisez la barre d'outils en bas pour commencer üëá
    </div>
</div>

<div class="validation-modal" id="validation-modal">
    <div class="validation-content">
        <h3>üîç V√©rification du devoir</h3>
        <div class="validation-list" id="validation-list"></div>
        <div class="validation-buttons">
            <button class="btn-modal btn-cancel" onclick="closeValidation()">Corriger</button>
            <button class="btn-modal btn-confirm" onclick="exportAfterValidation()" id="btn-confirm-export">Exporter quand m√™me</button>
        </div>
    </div>
</div>

<div class="tools-panel">
    <button class="btn-tool btn-qcm" onclick="addBlock('QCU')">üîò QCU</button>
    <button class="btn-tool btn-vf" onclick="addBlock('VF')">‚úÖ Vrai/Faux</button>
    <button class="btn-tool btn-text" onclick="addBlock('NUMBER')">üî¢ Nombre</button>
    <button class="btn-tool btn-text" onclick="addBlock('SHORT')">‚úçÔ∏è Texte</button>
    <button class="btn-tool btn-text" onclick="addBlock('SEPARATOR')">‚ûñ S√©parateur</button>
    <button class="btn-tool btn-text" onclick="addBlock('TITLE')">üî§ Titre</button>
    <button class="btn-tool btn-text" onclick="addBlock('BOX_NOTE')">üóíÔ∏è Note</button>
    <button class="btn-tool btn-text" onclick="addBlock('ENC_KQQOQCP')">üß© Encadr√© 6W</button>
    <button class="btn-tool btn-text" onclick="addBlock('ENC_PAD')">‚ö†Ô∏è Encadr√© PAD</button>
    <button class="btn-tool btn-text" onclick="addBlock('ENC_ITAMAMI')">üß∞ Encadr√© ITAMaMi</button>
    <span style="width:1px;background:rgba(255,255,255,0.2);margin:0 8px;"></span>
    <button class="btn-tool btn-doc" onclick="addBlock('DOC')">üìÑ Doc</button>
    <span style="width:1px;background:rgba(255,255,255,0.2);margin:0 8px;"></span>
    <button class="btn-tool" style="background:linear-gradient(135deg, #8b5cf6, #7c3aed);" onclick="exportTemplate()">üì§ Template IA</button>
    <button class="btn-tool" style="background:linear-gradient(135deg, #0ea5e9, #0284c7);" onclick="saveDraftJSON()">üíæ Sauvegarder JSON</button>
    <button class="btn-tool" style="background:linear-gradient(135deg, #06b6d4, #0891b2);" onclick="importJSON()">üì• Import JSON</button>
    <span style="width:1px;background:rgba(255,255,255,0.2);margin:0 8px;"></span>
    <button class="btn-tool btn-export" onclick="attemptExport()">üöÄ EXPORTER</button>
</div>

<script>
    let qCount = 0;
    window.MasterWidgets = window.MasterWidgets || (function() {
        const registry = {};
        return {
            register(type, def) {
                if (!type || !def || typeof def !== "object") return;
                registry[type] = def;
            },
            get(type) {
                return registry[type] || null;
            },
            all() {
                return registry;
            },
            init() {
                this._initialized = true;
            }
        };
    })();

    function createEncWidgetDef(title, lines) {
        return {
            kind: "enc",
            countAsQuestion: true,
            title,
            lines,
            exportToBlueprint(block, ctx) {
                const activeRows = getActiveEncRows(block);
                if (!activeRows.length) return [];
                const rowPoints = splitPoints(ctx.bareme, activeRows.length);
                const explanation = block.querySelector('.q-explain')?.value?.trim() || "";
                return activeRows.map((row, idx) => {
                    const subqid = row.dataset.subqid || createStableQid();
                    row.dataset.subqid = subqid;
                    const lineLabel = row.dataset.label || `Ligne ${idx + 1}`;
                    return {
                        type: "question",
                        qid: subqid,
                        label: `${ctx.qCounter}${String.fromCharCode(97 + idx)}`,
                        competence: ctx.competence,
                        bareme: rowPoints[idx] ?? 0,
                        inputType: "texte_exact",
                        autocorrect: true,
                        questionText: `${ctx.enoncePlain} ‚Äî ${lineLabel}`,
                        reponseCorrecte: [],
                        reponseAttendue: explanation
                    };
                });
            },
            exportToStudentHTML(block, ctx) {
                const activeRows = getActiveEncRows(block);
                if (!activeRows.length) return "";
                let html = `
                    <div class="question-block">
                        <span class="q-label">${ctx.qCounter}</span><span class="q-comp">${ctx.competence}</span><span class="q-points">${ctx.bareme} pts</span>
                        <div class="q-text">${ctx.enonceHtml}</div>
                        <div class="table-wrapper">
                            <table class="eval-table">
                                <tbody>
                `;
                activeRows.forEach((row, idx) => {
                    const lineLabel = row.dataset.label || `Ligne ${idx + 1}`;
                    const subqid = row.dataset.subqid || createStableQid();
                    row.dataset.subqid = subqid;
                    html += `
                        <tr>
                            <td>${lineLabel}</td>
                            <td><textarea class="reponse-eleve answer-input" data-qid="${subqid}" rows="2" style="width:100%; min-height:54px;" placeholder="Votre r√©ponse"></textarea></td>
                        </tr>
                    `;
                });
                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
                return html;
            },
            importFromBlueprint(items) {
                const first = items[0] || {};
                const titlePart = String(first.questionText || "").split("‚Äî")[0].trim();
                const competence = first.competence || first.comp || "C1";
                const total = items.reduce((sum, i) => sum + (parseFloat(i.bareme || i.points || 0) || 0), 0);
                return {
                    enonce: titlePart,
                    competence,
                    points: Number(total.toFixed(2)),
                    explanation: getFlexibleText(first, ['reponseAttendue', 'explication', 'correction', 'justification']),
                    lignes: items.map((i) => ({
                        label: String(i.questionText || "").split("‚Äî")[1]?.trim() || "",
                        subqid: i.qid || createStableQid(),
                        enabled: true,
                        preview: Array.isArray(i.reponseCorrecte) ? i.reponseCorrecte.join("; ") : String(i.reponseCorrecte || "")
                    }))
                };
            }
        };
    }

    window.MasterWidgets.register("SEPARATOR", {
        kind: "visual",
        countAsQuestion: false,
        exportToBlueprint() { return []; },
        exportToStudentHTML() {
            return `<div class="document-box" style="background:#f8fafc;border-color:#cbd5e1;"><hr style="border:none;border-top:3px solid #94a3b8;"></div>`;
        },
        importFromBlueprint() { return null; }
    });
    window.MasterWidgets.register("TITLE", {
        kind: "visual",
        countAsQuestion: false,
        exportToBlueprint() { return []; },
        exportToStudentHTML(block) {
            const text = block.querySelector('.q-enonce')?.value || "";
            return `<div class="document-box" style="background:#eef2ff;border-color:#a5b4fc;"><h4 style="margin:0;">${text}</h4></div>`;
        },
        importFromBlueprint() { return null; }
    });
    window.MasterWidgets.register("BOX_NOTE", {
        kind: "visual",
        countAsQuestion: false,
        exportToBlueprint() { return []; },
        exportToStudentHTML(block) {
            const title = block.querySelector('.q-enonce')?.value || "Note";
            const content = (block.querySelector('.box-note-content')?.value || "").replace(/\n/g, "<br>");
            return `<div class="document-box" style="background:#fff7ed;border-color:#fdba74;"><h4>${title}</h4><p>${content}</p></div>`;
        },
        importFromBlueprint() { return null; }
    });
    window.MasterWidgets.register("ENC_KQQOQCP", createEncWidgetDef("Compl√©ter le tableau QQOQCP", ["Quoi ?", "Qui ?", "O√π ?", "Quand ?", "Comment ?", "Pourquoi ?"]));
    window.MasterWidgets.register("ENC_PAD", createEncWidgetDef("Compl√©ter le tableau PAD", ["Op√©rateur", "Danger", "Situation dangereuse", "√âv√©nement d√©clencheur", "Dommage"]));
    window.MasterWidgets.register("ENC_ITAMAMI", createEncWidgetDef("Compl√©ter le tableau ITAMaMi", ["Individu", "T√¢che", "Activit√©", "Mat√©riel", "Milieu"]));

    function createStableQid() {
        return `q_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
    }

    function getWidgetDef(type) {
        return window.MasterWidgets && typeof window.MasterWidgets.get === "function"
            ? window.MasterWidgets.get(type)
            : null;
    }

    function isWidgetType(type) {
        return !!getWidgetDef(type);
    }

    function isVisualWidgetType(type) {
        const def = getWidgetDef(type);
        return !!(def && def.countAsQuestion === false);
    }

    function countsAsQuestionType(type) {
        if (type === "DOC") return false;
        return !isVisualWidgetType(type);
    }

    function getCountedQuestionBlocks() {
        return Array.from(document.querySelectorAll('.question-block')).filter((block) => countsAsQuestionType(block.dataset.type));
    }

    function isEncType(type) {
        const def = getWidgetDef(type);
        return !!(def && def.kind === "enc");
    }

    function normalizeEncLabel(label) {
        return String(label || "").toLowerCase().replace(/\s+/g, " ").trim();
    }

    function getEncTypeFromLabel(label) {
        const norm = normalizeEncLabel(label);
        const allTypes = Object.keys(window.MasterWidgets.all()).filter((type) => isEncType(type));
        for (let i = 0; i < allTypes.length; i++) {
            const type = allTypes[i];
            const lines = getWidgetDef(type)?.lines || [];
            const found = lines.some((line) => normalizeEncLabel(line) === norm);
            if (found) return type;
        }
        return null;
    }

    function setEncRowEnabled(row, enabled) {
        row.dataset.enabled = enabled ? "1" : "0";
        row.classList.toggle("enc-row-disabled", !enabled);
        const answer = row.querySelector(".enc-expected");
        if (answer) answer.disabled = !enabled;
        const btn = row.querySelector(".enc-toggle-btn");
        if (btn) {
            btn.textContent = enabled ? "√ó" : "‚Ü∫";
            btn.title = enabled ? "D√©sactiver cette ligne" : "R√©activer cette ligne";
        }
    }

    function toggleEncRow(btn) {
        const row = btn.closest(".enc-row");
        if (!row) return;
        const enabled = row.dataset.enabled !== "0";
        setEncRowEnabled(row, !enabled);
    }

    function getEncRows(block) {
        return Array.from(block.querySelectorAll(".enc-row"));
    }

    function getActiveEncRows(block) {
        return getEncRows(block).filter((row) => row.dataset.enabled !== "0");
    }

    function splitPoints(total, count) {
        const c = Math.max(0, Number(count) || 0);
        if (c === 0) return [];
        const t = Number(total) || 0;
        const base = Math.floor((t * 100) / c) / 100;
        const points = Array.from({ length: c }, () => base);
        const used = base * (c - 1);
        points[c - 1] = Number((t - used).toFixed(2));
        return points;
    }

    // --- MISE √Ä JOUR COMPTEUR ---
    function updateStats() {
        const questions = getCountedQuestionBlocks().length;
        let totalPoints = 0;
        getCountedQuestionBlocks().forEach((block) => {
            totalPoints += parseFloat(block.querySelector('.q-points')?.value) || 0;
        });
        document.getElementById('quiz-stats').textContent = 
            `${questions} question${questions > 1 ? 's' : ''} - ${totalPoints} pt${totalPoints > 1 ? 's' : ''}`;
    }

    // --- FONCTION AUTO-RESIZE ---
    function autoResize(el) {
        el.style.height = 'auto';
        el.style.height = el.scrollHeight + 'px';
    }

    // --- FONCTIONS DE BASE ---
    function insertAfter(newNode, referenceNode) {
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
    }

    function removeBlock(btn) {
        if(confirm("Supprimer ce bloc ?")) {
            btn.closest('.question-block').remove();
            renumberQuestions();
            updateStats();
            if(document.querySelectorAll('.question-block').length === 0) {
                document.getElementById('empty-msg').style.display = 'block';
            }
        }
    }

    function renumberQuestions() {
        let i = 1;
        getCountedQuestionBlocks().forEach(el => {
            el.querySelector('.q-num').textContent = i++;
        });
        document.querySelectorAll('.question-block').forEach((el) => {
            const type = el.dataset.type;
            if (!countsAsQuestionType(type)) {
                const numEl = el.querySelector('.q-num');
                if (numEl) numEl.textContent = "‚Ä¢";
            }
        });
        qCount = i - 1;
    }

    // --- CR√âATION DE BLOCS ---
    function createBlockSkeleton(type, insertAfterElem = null) {
        document.getElementById('empty-msg').style.display = 'none';
        
        const div = document.createElement('div');
        div.className = `question-block ${type === 'DOC' ? 'doc-block' : ''}`;
        div.dataset.type = type;
        div.dataset.qid = createStableQid();
        
        let headerHtml = '';
        
        if (type === 'DOC') {
            headerHtml = `
                <div class="q-header" style="background:linear-gradient(135deg, #fff3cd 0%, #fef3c7 100%); border-color:#fbbf24;">
                    <div class="q-num">üìÑ</div>
                    <textarea class="doc-title-input auto-grow" rows="1" placeholder="Titre du document" oninput="autoResize(this)" style="font-weight:bold; background:transparent; border:none; border-bottom:2px dashed #f59e0b; color:#d97706; flex:1;"></textarea>
                    <button class="delete-btn" onclick="removeBlock(this)">Supprimer</button>
                </div>
            `;
        } else {
            if (countsAsQuestionType(type)) qCount++;
            headerHtml = `
                <div class="q-header">
                    <div class="q-num">${countsAsQuestionType(type) ? qCount : "‚Ä¢"}</div>
                    <textarea class="q-enonce auto-grow" rows="1" placeholder="√ânonc√© de la question..." oninput="autoResize(this)"></textarea>
                    <div class="q-controls">
                        <select class="q-comp" style="width:80px; font-weight:bold;" onchange="updateStats()">
                            <option value="C1">C1</option><option value="C2">C2</option><option value="C3">C3</option><option value="C4">C4</option><option value="C5">C5</option><option value="C6">C6</option>
                        </select>
                        <input type="number" class="q-points" value="1" step="0.5" style="width:60px; text-align:center; font-weight:bold;" title="Points" onchange="updateStats()">
                        <button class="delete-btn" onclick="removeBlock(this)">‚úï</button>
                    </div>
                </div>
            `;
        }
        
        div.innerHTML = headerHtml + `<div class="block-content"></div>`;
        
        if (type === 'DOC') {
             div.innerHTML += `<button class="insert-btn" onclick="addQuestionAfter(this)">‚ûï Ajouter une question sous ce document</button>`;
        }

        const container = document.getElementById('quiz-content');
        if (insertAfterElem) {
            insertAfter(div, insertAfterElem);
        } else {
            container.appendChild(div);
        }
        
        div.querySelectorAll('textarea.auto-grow').forEach(ta => autoResize(ta));
        setTimeout(() => div.scrollIntoView({behavior: "smooth", block: "center"}), 100);
        renumberQuestions();
        updateStats();
        return div.querySelector('.block-content');
    }

    function addQuestionAfter(btn) {
        const block = btn.closest('.question-block');
        addBlock('QCU', block);
    }

    function addBlock(type, insertAfterElem = null) {
        const content = createBlockSkeleton(type, insertAfterElem);
        const uid = Date.now();

        if (type === 'QCU') {
            const containerId = `opts_${uid}`;
            content.innerHTML = `
                <div class="config-zone">
                    <span class="config-label">üìù Options (Cochez la bonne r√©ponse)</span>
                    <div id="${containerId}"></div>
                    <button onclick="addOption('${containerId}')" style="margin-top:10px;font-size:0.85em;cursor:pointer;background:linear-gradient(135deg, #e9ecef, #dee2e6);border:none;padding:6px 12px;border-radius:6px;font-weight:bold;color:#495057;transition:all 0.2s;">+ Ajouter une option</button>
                </div>
            `;
            addOption(containerId);
            addOption(containerId);
        } 
        else if (type === 'VF') {
            content.innerHTML = `
                <div class="config-zone" style="background:linear-gradient(135deg, #e8f5e9 0%, #f0fdf4 100%); border-color:#86efac;">
                    <span class="config-label" style="color:#15803d;">üéØ R√©ponse attendue</span>
                    <label style="cursor:pointer;margin-right:20px;font-weight:bold;color:#15803d;"><input type="radio" name="vf_${uid}" value="vrai" checked> Vrai</label>
                    <label style="cursor:pointer;font-weight:bold;color:#dc2626;"><input type="radio" name="vf_${uid}" value="faux"> Faux</label>
                </div>
            `;
        }
        else if (type === 'SHORT' || type === 'NUMBER') {
            content.innerHTML = `
                <div class="config-zone">
                    <span class="config-label">üéØ R√©ponse attendue</span>
                    <textarea class="valid-answers auto-grow" rows="1" oninput="autoResize(this)" placeholder="${type === 'NUMBER' ? 'Ex: 10' : 'Ex: Paris; la capitale'}" style="border:2px solid #22c55e; font-family:monospace; font-weight:bold; color:#15803d; width:100%;"></textarea>
                </div>
            `;
        }
        else if (isEncType(type)) {
            const def = getWidgetDef(type);
            const rowsHtml = def.lines.map((lineLabel) => `
                <tr class="enc-row" data-label="${lineLabel}" data-subqid="${createStableQid()}" data-enabled="1">
                    <td class="enc-label-cell">${lineLabel}</td>
                    <td class="enc-answer-cell">
                        <textarea class="enc-expected auto-grow" rows="2" oninput="autoResize(this)" placeholder="R√©ponse attendue (optionnelle)..."></textarea>
                    </td>
                    <td style="width:56px; text-align:center;">
                        <button class="enc-toggle-btn" type="button" onclick="toggleEncRow(this)" title="D√©sactiver cette ligne">√ó</button>
                    </td>
                </tr>
            `).join("");

            content.innerHTML = `
                <div class="config-zone" style="background:linear-gradient(135deg, #eef2ff 0%, #f8fafc 100%); border-color:#a5b4fc;">
                    <span class="config-label">üß© Tableau encadr√© (${def.lines.length} lignes pr√©d√©finies)</span>
                    <table class="enc-table" aria-label="Tableau encadr√©">
                        <thead>
                            <tr>
                                <th>Rubrique</th>
                                <th>R√©ponse attendue / guide</th>
                                <th>Actif</th>
                            </tr>
                        </thead>
                        <tbody>${rowsHtml}</tbody>
                    </table>
                </div>
            `;

            const block = content.closest(".question-block");
            if (block) block.classList.add("enc-block");
            const enonceField = block ? block.querySelector(".q-enonce") : null;
            if (enonceField && !enonceField.value.trim()) {
                enonceField.value = def.title;
                autoResize(enonceField);
            }
        }
        else if (type === 'SEPARATOR') {
            content.innerHTML = `
                <div class="config-zone" style="background:#f8fafc; border-color:#cbd5e1;">
                    <span class="config-label">S√©parateur visuel (non export√© dans le blueprint)</span>
                    <hr style="border:none; border-top:3px solid #94a3b8; margin:12px 0;">
                </div>
            `;
        }
        else if (type === 'TITLE') {
            content.innerHTML = `
                <div class="config-zone" style="background:#f8fafc; border-color:#cbd5e1;">
                    <span class="config-label">Titre intercal√© (non export√© dans le blueprint)</span>
                    <p style="font-weight:700; color:#334155;">Ce bloc sert uniquement de mise en forme.</p>
                </div>
            `;
            const block = content.closest(".question-block");
            const enonceField = block ? block.querySelector(".q-enonce") : null;
            if (enonceField && !enonceField.value.trim()) {
                enonceField.value = "Titre de section";
                autoResize(enonceField);
            }
        }
        else if (type === 'BOX_NOTE') {
            content.innerHTML = `
                <div class="config-zone" style="background:#fff7ed; border-color:#fdba74;">
                    <span class="config-label">Encadr√© note/aide (non export√© dans le blueprint)</span>
                    <textarea class="box-note-content auto-grow" rows="3" oninput="autoResize(this)" placeholder="Texte de note ou d'aide..."></textarea>
                </div>
            `;
            const block = content.closest(".question-block");
            const enonceField = block ? block.querySelector(".q-enonce") : null;
            if (enonceField && !enonceField.value.trim()) {
                enonceField.value = "Note";
                autoResize(enonceField);
            }
        }
        else if (type === 'DOC') {
            content.innerHTML = `
                <textarea class="doc-content auto-grow" style="min-height:100px; width:100%;" placeholder="Contenu du document..." oninput="autoResize(this)"></textarea>
            `;
        }
        
        if (type !== 'DOC' && type !== 'SEPARATOR' && type !== 'TITLE' && type !== 'BOX_NOTE') {
            content.innerHTML += `
                <div style="margin-top:15px;">
                    <textarea class="q-explain auto-grow" rows="1" oninput="autoResize(this)" placeholder="üí° Explication pour la correction..." style="font-size:0.9em;color:#64748b;background:#f8fafc;border:2px dashed #cbd5e0;width:100%;border-radius:6px;padding:10px;"></textarea>
                </div>
            `;
        }
    }

    function addOption(containerId) {
        const div = document.createElement('div');
        div.className = 'option-row';
        const inputType = 'radio';
        const nameGroup = `grp_${containerId}`;
        div.innerHTML = `
            <input type="${inputType}" name="${nameGroup}" class="correct-check" title="Est-ce la bonne r√©ponse ?">
            <textarea class="opt-text auto-grow" rows="1" oninput="autoResize(this)" placeholder="R√©ponse possible..."></textarea>
            <button onclick="this.parentElement.remove()" style="color:#e74c3c;border:none;background:none;cursor:pointer;font-weight:bold;margin-top:10px;font-size:1.2em;transition:all 0.2s;" onmouseover="this.style.color='#dc2626'; this.style.transform='scale(1.2)'" onmouseout="this.style.color='#e74c3c'; this.style.transform='scale(1)'">√ó</button>
        `;
        document.getElementById(containerId).appendChild(div);
    }

    // ============================================================
    // üîç SYST√àME DE VALIDATION
    // ============================================================

    function validateQuiz() {
        const issues = [];
        const warnings = [];
        
        // V√©rifications de base
        const titre = document.getElementById('titre-devoir').value.trim();
        const devoirId = document.getElementById('devoir-id').value.trim();
        
        if (!titre) issues.push("‚ùå Titre du devoir manquant");
        if (!devoirId) issues.push("‚ùå ID unique manquant");
        
        // V√©rification RGPD basique
        if (titre.match(/\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/)) {
            issues.push("‚ö†Ô∏è RGPD : Le titre semble contenir un nom/pr√©nom");
        }
        
        // V√©rification des questions
        const questions = getCountedQuestionBlocks();
        if (questions.length === 0) {
            issues.push("‚ùå Aucune question cr√©√©e");
            return { issues, warnings, canExport: false };
        }
        
        let totalPoints = 0;
        const competences = new Set();
        
        questions.forEach((q, idx) => {
            const num = idx + 1;
            const enonce = q.querySelector('.q-enonce').value.trim();
            const points = parseFloat(q.querySelector('.q-points').value) || 0;
            const comp = q.querySelector('.q-comp').value;
            const type = q.dataset.type;
            
            if (!enonce) issues.push(`‚ùå Question ${num} : √©nonc√© manquant`);
            if (points <= 0) warnings.push(`‚ö†Ô∏è Question ${num} : bar√®me invalide (${points})`);
            
            // V√©rification RGPD dans les √©nonc√©s
            if (enonce.match(/\b[A-Z][a-z]+\s+[A-Z][a-z]+\b/)) {
                issues.push(`‚ö†Ô∏è RGPD : Question ${num} semble contenir un nom/pr√©nom`);
            }
            
            totalPoints += points;
            competences.add(comp);
            
            // V√©rifications sp√©cifiques par type
            if (type === 'QCU') {
                const options = q.querySelectorAll('.opt-text');
                const checked = q.querySelectorAll('.correct-check:checked');
                
                let validOptions = 0;
                options.forEach(opt => {
                    if (opt.value.trim()) validOptions++;
                });
                
                if (validOptions < 2) warnings.push(`‚ö†Ô∏è Question ${num} : moins de 2 options valides`);
                if (checked.length === 0) issues.push(`‚ùå Question ${num} : aucune bonne r√©ponse coch√©e`);
                if (checked.length > 1) issues.push(`‚ùå Question ${num} : QCU avec plusieurs bonnes r√©ponses`);
            }
            
            if (type === 'SHORT' || type === 'NUMBER') {
                const reponse = q.querySelector('.valid-answers').value.trim();
                if (!reponse) issues.push(`‚ùå Question ${num} : r√©ponse attendue manquante`);
            }

            if (isEncType(type)) {
                const activeRows = getActiveEncRows(q);
                if (activeRows.length === 0) {
                    issues.push(`‚ùå Question ${num} : aucune ligne active dans l'encadr√©`);
                }
            }
            
        });
        
        // Statistiques globales
        if (totalPoints === 0) issues.push("‚ùå Total des points = 0");
        if (totalPoints > 20) warnings.push(`‚ö†Ô∏è Total √©lev√© : ${totalPoints} points`);
        if (competences.size === 1) warnings.push(`‚ö†Ô∏è Une seule comp√©tence utilis√©e : ${Array.from(competences)[0]}`);
        
        return { issues, warnings, canExport: issues.length === 0 };
    }

    function showValidation(validation) {
        const modal = document.getElementById('validation-modal');
        const list = document.getElementById('validation-list');
        const confirmBtn = document.getElementById('btn-confirm-export');
        
        list.innerHTML = '';
        
        if (validation.issues.length === 0 && validation.warnings.length === 0) {
            list.innerHTML = '<div style="text-align:center; color:#059669; font-weight:600; padding:20px;">‚úÖ Tout semble correct !</div>';
            confirmBtn.textContent = "Exporter";
            confirmBtn.className = "btn-modal btn-confirm";
        } else {
            validation.issues.forEach(issue => {
                list.innerHTML += `<div class="validation-item error">${issue}</div>`;
            });
            validation.warnings.forEach(warning => {
                list.innerHTML += `<div class="validation-item">${warning}</div>`;
            });
            
            if (validation.issues.length > 0) {
                confirmBtn.textContent = "Exporter quand m√™me";
                confirmBtn.className = "btn-modal btn-force";
            } else {
                confirmBtn.textContent = "Exporter";
                confirmBtn.className = "btn-modal btn-confirm";
            }
        }
        
        modal.style.display = 'flex';
    }

    function closeValidation() {
        document.getElementById('validation-modal').style.display = 'none';
    }

    function exportAfterValidation() {
        closeValidation();
        document.querySelector('.btn-export').classList.add('exporting');
        setTimeout(() => {
            performExportWithDelay();
            document.querySelector('.btn-export').classList.remove('exporting');
        }, 500);
    }

    // ============================================================
    // üöÄ EXPORT AM√âLIOR√â
    // ============================================================

    function attemptExport() {
        const validation = validateQuiz();
        showValidation(validation);
    }

    function generateStudentTemplate(titre, devoirId, contentHTML, competences, blueprintData = null) {
        const compList = competences.map(c => `<li><span class="comp-tag">${c}</span></li>`).join('');
        const embeddedBlueprintScript = blueprintData ? `
<script>
    window.__PSE_BLUEPRINT = ${JSON.stringify(blueprintData, null, 2)};
<\/script>
        ` : '';

        
        return `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSE - ${titre}</title>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://firestore.googleapis.com" crossorigin>
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #f0f2f5 0%, #e8ecef 100%); 
            color: #1a1a2e; line-height: 1.6; padding: 12px; 
            min-height: 100vh;
        }
        .container { 
            max-width: 900px; margin: 0 auto; background: #fff; 
            border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.12); overflow: hidden; 
        }
        .header { 
            background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 50%, #74b9ff 100%); 
            color: #fff; padding: 32px 30px; text-align: center; 
            position: relative; overflow: hidden;
        }
        .header::before {
            content: ''; position: absolute; top: -50%; left: -50%;
            width: 200%; height: 200%; background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: headerShimmer 6s ease-in-out infinite;
        }
        @keyframes headerShimmer {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(180deg); }
        }
        .header h1 { font-size: 1.6em; margin-bottom: 6px; font-weight: 700; position: relative; z-index: 1; }
        .header .subtitle { font-size: 1.05em; opacity: 0.95; position: relative; z-index: 1; }
        
        .competences-box { 
            background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%); 
            border-left: 5px solid #6c5ce7; margin: 24px 28px; padding: 18px 22px; 
            border-radius: 0 10px 10px 0; box-shadow: 0 4px 15px rgba(108, 92, 231, 0.08);
        }
        .competences-box h3 { color: #6c5ce7; margin-bottom: 12px; font-size: 1em; font-weight: 600; }
        .competences-box ul { list-style: none; padding: 0; display:flex; gap:12px; flex-wrap:wrap; }
        .comp-tag { 
            display: inline-block; background: linear-gradient(135deg, #6c5ce7, #8b5cf6); 
            color: #fff; padding: 2px 12px; border-radius: 6px; font-weight: 600; 
            font-size: 0.8em; box-shadow: 0 2px 4px rgba(108, 92, 231, 0.2);
        }
        .body-content { padding: 0 28px 28px; }
        .identification { 
            background: linear-gradient(135deg, #fff3e0 0%, #fff8f1 100%); 
            border: 2px solid #ff9800; border-radius: 12px; padding: 18px 22px; 
            margin: 24px 0; box-shadow: 0 4px 12px rgba(255, 152, 0, 0.1);
        }
        .identification h3 { color: #e65100; margin-bottom: 12px; font-weight: 600; }
        .identification label { font-weight: 600; font-size: 0.9em; margin-right:12px; }
        .identification input { 
            padding: 10px 14px; border: 2px solid #ffcc80; border-radius: 8px; 
            font-size: 0.95em; width: 200px; text-transform: uppercase; 
            transition: all 0.2s ease; font-weight: 600;
        }
        .identification input:focus {
            border-color: #ff9800; outline: none; 
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .document-box { 
            background: linear-gradient(135deg, #fff8e1 0%, #fffbef 100%); 
            border: 1px solid #ffc107; border-radius: 10px; padding: 16px 20px; 
            margin: 16px 0; font-size: 0.9em; border-left: 6px solid #ffb74d; 
            box-shadow: 0 3px 10px rgba(255, 193, 7, 0.1);
        }
        .document-box h4 { 
            color: #f57f17; margin-bottom: 10px; font-size: 1.1em; 
            border-bottom: 2px solid #ffe0b2; padding-bottom: 6px; font-weight: 600;
        }

        .question-block { 
            background: linear-gradient(135deg, #fafbff 0%, #f8fafc 100%); 
            border: 2px solid #e2e8f0; border-radius: 12px; padding: 18px 20px; 
            margin: 16px 0; box-shadow: 0 4px 15px rgba(0,0,0,0.06);
            transition: all 0.2s ease;
        }
        .question-block:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        .q-label { 
            display: inline-block; background: linear-gradient(135deg, #6c5ce7, #8b5cf6); 
            color: #fff; width: 32px; height: 32px; line-height: 32px; text-align: center; 
            border-radius: 50%; font-size: 0.85em; font-weight: bold; margin-right: 10px; 
            box-shadow: 0 3px 8px rgba(108, 92, 231, 0.3);
        }
        .q-comp { 
            display: inline-block; background: linear-gradient(135deg, #e8eaf6, #f3e5f5); 
            color: #3949ab; padding: 3px 10px; border-radius: 6px; font-size: 0.75em; 
            font-weight: 600; margin-left: 8px; 
        }
        .q-points { 
            float: right; background: linear-gradient(135deg, #e0f7fa, #e1f5fe); 
            color: #006064; padding: 3px 12px; border-radius: 15px; font-size: 0.78em; 
            font-weight: 600; 
        }
        .q-text { 
            margin: 12px 0; font-size: 0.95em; font-weight: 500; color: #2c3e50; 
            line-height: 1.6;
        }
        
        .checkbox-group { display: flex; flex-direction: column; gap: 10px; margin-top: 12px; }
        .checkbox-group label { 
            display: flex; align-items: center; gap: 12px; padding: 12px 16px; 
            background: linear-gradient(135deg, #fff 0%, #fafafa 100%); 
            border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; 
            font-size: 0.9em; transition: all 0.2s ease;
        }
        .checkbox-group label:hover { 
            background: linear-gradient(135deg, #f3f0ff, #f8f5ff); 
            border-color: #a29bfe; transform: translateX(4px);
        }
        .checkbox-group input { width: 20px; height: 20px; accent-color: #6c5ce7; }
        
        .answer-input { 
            padding: 12px 16px; border: 3px solid #d1c4e9; border-radius: 8px; 
            font-size: 0.95em; width: 100%; max-width: 320px; 
            transition: all 0.2s ease; font-weight: 500;
            resize: none; overflow: hidden; min-height: 40px;
        }
        .answer-input:focus {
            border-color: #6c5ce7; outline: none;
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.1);
            transform: translateY(-1px);
        }
        .answer-select { 
            padding: 12px 16px; border: 3px solid #d1c4e9; border-radius: 8px; 
            font-size: 0.95em; background: #fff; width: 100%; font-weight: 500;
            transition: all 0.2s ease;
        }
        .answer-select:focus {
            border-color: #6c5ce7; outline: none;
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.1);
        }
        
        .eval-table { 
            width: 100%; border-collapse: collapse; font-size: 0.9em; 
            margin-top: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border-radius: 8px; overflow: hidden;
        }
        .eval-table td { 
            padding: 12px; border-bottom: 1px solid #f0f0f0; 
            background: linear-gradient(135deg, #fff 0%, #fafafa 100%);
        }
        
        .submit-section { text-align: center; margin: 40px 0; }
        .submit-btn { 
            background: linear-gradient(135deg, #6c5ce7, #a29bfe); color: #fff; 
            border: none; padding: 16px 48px; font-size: 1.1em; font-weight: 700; 
            border-radius: 50px; cursor: pointer; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            box-shadow: 0 8px 25px rgba(108, 92, 231, 0.3);
            position: relative; overflow: hidden;
        }
        .submit-btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        .submit-btn:hover::before { left: 100%; }
        .submit-btn:hover { 
            transform: translateY(-3px) scale(1.02); 
            box-shadow: 0 12px 35px rgba(108, 92, 231, 0.4); 
        }
        .submit-btn:disabled { 
            background: #bbb; cursor: not-allowed; transform: none; 
            box-shadow: none;
        }
        
        /* ANIMATIONS */
        .question-block { animation: slideInUp 0.5s ease-out; }
        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* RESPONSIVE */
        @media (max-width: 768px) {
            .body-content { padding: 0 16px 16px; }
            .competences-box { margin: 16px; }
            .identification { margin: 16px 0; padding: 16px; }
            .question-block { margin: 12px 0; padding: 16px; }
        }
    </style>
</head>
<body data-id-exercice="${devoirId}">
<div class="container">
    <div class="header">
        <h1>${titre}</h1>
        <div class="subtitle">Quiz Auto-Corrig√©</div>
    </div>
    <div class="competences-box">
        <h3>Comp√©tences √©valu√©es</h3>
        <ul>${compList}</ul>
    </div>
    <div class="body-content">

    <div class="identification">
        <h3>Identification</h3>
        <div>
            <label for="code-eleve">Code √©l√®ve :</label>
            <input type="text" id="code-eleve" class="reponse-eleve" data-qid="code_eleve" placeholder="Votre code">
        </div>
    </div>

    ${contentHTML}

    <div class="submit-section">
        <button class="submit-btn" id="btn-envoyer" onclick="window.tenterEnvoi()">Envoyer ma copie üì§</button>
        <p id="envoi-status" style="font-size:0.85em; color:#666; margin-top:12px;">Le syst√®me se charge...</p>
    </div>

    </div>
</div>

<script>
    const focus = { focusLeaves: 0, copyAttempts: 0 };
    function getAntiCheatOptions() {
        return (window.__PSE_BLUEPRINT && window.__PSE_BLUEPRINT.options) || { antiLeave: true, antiPaste: true, maxLeaves: 2 };
    }

    // Auto-resize pour les zones de texte
    function autoResize(el) {
        el.style.height = 'auto';
        el.style.height = el.scrollHeight + 'px';
    }

    // Appliquer l'auto-resize √† tous les champs texte
    document.addEventListener('DOMContentLoaded', function() {
        const textInputs = document.querySelectorAll('textarea, input[type="text"]');
        textInputs.forEach(input => {
            if (input.tagName === 'TEXTAREA') {
                input.addEventListener('input', () => autoResize(input));
                autoResize(input); // Taille initiale
            }
        });
    });

    document.addEventListener('visibilitychange', () => {
        const antiCheatOptions = getAntiCheatOptions();
        if (antiCheatOptions.antiLeave !== false && document.visibilityState === 'hidden') {
            focus.focusLeaves += 1;
        }
    });

    window.addEventListener('blur', () => {
        const antiCheatOptions = getAntiCheatOptions();
        if (antiCheatOptions.antiLeave !== false) {
            focus.focusLeaves += 1;
        }
    });

    document.addEventListener('copy', () => {
        focus.copyAttempts += 1;
    });

    document.addEventListener('paste', (event) => {
        const antiCheatOptions = getAntiCheatOptions();
        focus.copyAttempts += 1;
        if (antiCheatOptions.antiPaste !== false) {
            event.preventDefault();
        }
    });

    // Configuration Runner
    window.tenterEnvoi = async function() {
        const codeInput = document.getElementById('code-eleve');
        const code = (codeInput.value || '').trim().toUpperCase();
        if(!code || code.length < 2) { alert("Code √©l√®ve requis !"); return; }
        
        const btn = document.getElementById('btn-envoyer');
        btn.disabled = true;
        btn.textContent = "Envoi en cours...";

        if (typeof window.envoyerCopie === 'function') {
            try {
                const classeLS = (localStorage.getItem('userClasse') || '').trim();
                const elevePayload = classeLS
                    ? { code: code, classe: classeLS, blueprintEmbedded: true, focus: focus }
                    : { code: code, blueprintEmbedded: true, focus: focus };
                await window.envoyerCopie(code, { external: 0 }, elevePayload);
                btn.textContent = "‚úÖ Envoy√© !";
                btn.style.background = "linear-gradient(135deg, #2ecc71, #27ae60)";
            } catch(e) {
                console.error(e);
                alert("Erreur: " + e.message);
                btn.disabled = false;
                btn.textContent = "R√©essayer";
            }
        } else {
            alert("Syst√®me non pr√™t. Rechargez la page.");
            btn.disabled = false;
        }
    };
<\/script>

${embeddedBlueprintScript}

<script type="module">
    const statusEl = document.getElementById("envoi-status");
    const segRaw = location.pathname.split("/").filter(Boolean)[0] || "";
    const seg = segRaw.includes(".") ? "" : segRaw;
    const prefixes = [];
    if (seg) prefixes.push("/" + seg);
    prefixes.push("/PSE");
    prefixes.push("");
    const uniquePrefixes = [...new Set(prefixes)];

    function buildUrl(prefix, relPath) {
        const p = prefix || "";
        const base = p ? p.replace(/\/+$, "") : "";
        const rel = String(relPath || "").replace(/^\/+/, "");
        return (base ? base + "/" : "/") + rel;
    }

    async function importWithPrefixes(fileRelativePath, optionalRelativePaths = []) {
        let lastError = null;
        const attempts = [];

        uniquePrefixes.forEach(prefix => attempts.push(buildUrl(prefix, fileRelativePath)));
        optionalRelativePaths.forEach(opt => {
            uniquePrefixes.forEach(prefix => attempts.push(buildUrl(prefix, opt)));
        });

        const uniqueAttempts = [...new Set(attempts)];

        for (const url of uniqueAttempts) {
            try {
                console.warn("Tentative import:", url);
                await import(url);
                return url;
            } catch (e) {
                lastError = e;
                console.warn("Import √©chou√©:", url, e);
            }
        }

        throw lastError || new Error("Impossible de charger le module: " + fileRelativePath);
    }

    try {
        statusEl.textContent = "Chargement des modules...";

        const annuaireUrl = "https://preventionsanteenvironnement.github.io/PSE/annuaire.js";
        const runnerUrl = "https://preventionsanteenvironnement.github.io/PSE/assets/pse-runner.js";

        await import(annuaireUrl);
        await import(runnerUrl);

        console.log("Modules charg√©s:", { annuaireUrl, runnerUrl, seg, prefixes: uniquePrefixes });
        statusEl.textContent = "Syst√®me pr√™t.";
    } catch(e) {
        console.error("Erreur modules:", e);
        statusEl.textContent = "Erreur de chargement des modules (chemins serveur √† v√©rifier).";
        statusEl.style.color = "red";
    }
<\/script>
</body>
</html>`;
    }

    // --- EXPORT TEMPLATE POUR IA ---
    function exportTemplate() {
        const questions = document.querySelectorAll('.question-block:not(.doc-block)');
        if (questions.length === 0) {
            alert("Cr√©ez d'abord au moins une question avant d'exporter le template.");
            return;
        }

        const devoirId = document.getElementById('devoir-id').value.trim() || `template_${Date.now()}`;
        const titre = document.getElementById('titre-devoir').value || "Template";
        const niveau = document.getElementById('niveau-cible').value || "Bac Pro";

        // Structure template avec instructions IA
        const template = {
            instructions: {
                mission: `Remplir ce devoir PSE niveau ${niveau} sur le th√®me : ${titre}`,
                regles_strictes: [
                    "RESPECTER exactement la structure JSON",
                    "NE JAMAIS modifier : id, qid, type, inputType, competence, bareme",
                    "GARDER tous les identifiants identiques",
                    "Niveau p√©dagogique : " + niveau,
                    "Utiliser le PDF cours fourni comme r√©f√©rence"
                ],
                autorisations: [
                    "Remplir uniquement : questionText, options[].label, reponseCorrecte, reponseAttendue, explication",
                    "Cr√©er des √©nonc√©s adapt√©s au niveau " + niveau,
                    "OBLIGATOIRE : R√©diger une correction compl√®te dans reponseAttendue",
                    "Corrections = explication p√©dagogique + justification + r√©f√©rence au cours",
                    "Exemple correction VF : 'Vrai. Le sommeil permet la r√©cup√©ration physique et mentale (cours p.15). Les phases de sommeil paradoxal consolident la m√©moire.'",
                    "R√©f√©rencer pr√©cis√©ment le cours : 'selon le document p.X', 'comme vu en cours chapitre Y'",
                    "Adapter les corrections au niveau " + niveau + " (vocabulaire, complexit√©)"
                ],
                formats_reponses: {
                    QCU: "1 seule bonne r√©ponse dans reponseCorrecte",
                    VF: "Justifier dans reponseAttendue pourquoi vrai ou faux + r√©f√©rence cours",
                    SHORT: "Accepter plusieurs formulations s√©par√©es par ; dans reponseCorrecte",
                    NUMBER: "Valeur num√©rique exacte + explication calcul dans reponseAttendue"
                },
                final: "SUPPRIMER ce champ instructions du JSON final"
            },
            id: devoirId,
            devoirId: devoirId,
            titre: titre + " [√Ä COMPL√âTER]",
            niveau: niveau,
            competences: [],
            version: "template_v1",
            autocorrect: true,
            content: []
        };

        const usedComps = new Set();
        let qCounter = 1;

        document.querySelectorAll('.question-block').forEach((block) => {
            const type = block.dataset.type;
            if (type === 'DOC') return; // Skip docs dans template

            const qidBase = block.dataset.qid;
            const competence = block.querySelector('.q-comp').value;
            const bareme = parseFloat(block.querySelector('.q-points').value) || 1;
            usedComps.add(competence);

            // Template selon type
            if (type === 'QCU') {
                const optCount = block.querySelectorAll('.option-row').length || 4;
                const emptyOptions = Array.from({length: optCount}, (_, i) => ({
                    value: `${qidBase}_opt${i+1}`,
                    label: `[OPTION ${i+1} √Ä REMPLIR]`
                }));

                template.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: "select",
                    autocorrect: true,
                    questionText: "[√âNONC√â √Ä REMPLIR]",
                    reponseCorrecte: "[ID_OPTION_CORRECTE]",
                    reponseAttendue: "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]",
                    explication: "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]",
                    options: emptyOptions
                });
                qCounter++;
            }
            else if (type === 'VF') {
                template.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: "vrai_faux",
                    autocorrect: true,
                    questionText: "[√âNONC√â √Ä REMPLIR]",
                    reponseCorrecte: "[vrai OU faux]",
                    reponseAttendue: "[JUSTIFICATION D√âTAILL√âE]",
                    explication: "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]"
                });
                qCounter++;
            }
            else if (type === 'SHORT' || type === 'NUMBER') {
                template.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: type === 'NUMBER' ? "number" : "texte_exact",
                    autocorrect: true,
                    questionText: "[√âNONC√â √Ä REMPLIR]",
                    reponseCorrecte: type === 'NUMBER' ? "[NOMBRE]" : ["[R√âPONSE1]", "[R√âPONSE2]"],
                    reponseAttendue: "[EXPLICATION AVEC CALCUL/JUSTIFICATION]",
                    explication: "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]",
                    tolerance: type === 'NUMBER' ? 0 : undefined
                });
                qCounter++;
            }
            else if (isEncType(type)) {
                const explanation = block.querySelector('.q-explain')?.value?.trim() || "[EXPLICATION D√âTAILL√âE √Ä R√âDIGER]";
                const activeRows = getActiveEncRows(block);
                if (activeRows.length === 0) return;
                const rowPoints = splitPoints(bareme, Math.max(1, activeRows.length));
                activeRows.forEach((row, idx) => {
                    const subqid = row.dataset.subqid || createStableQid();
                    row.dataset.subqid = subqid;
                    const lineLabel = row.dataset.label || `Ligne ${idx + 1}`;
                    template.content.push({
                        type: "question",
                        qid: subqid,
                        label: `${qCounter}${String.fromCharCode(97 + idx)}`,
                        competence: competence,
                        bareme: rowPoints[idx] ?? 0,
                        inputType: "texte_exact",
                        autocorrect: true,
                        questionText: "[√âNONC√â √Ä REMPLIR] ‚Äî " + lineLabel,
                        reponseCorrecte: [],
                        reponseAttendue: explanation,
                        explication: explanation
                    });
                });
                qCounter++;
            }
        });

        template.competences = Array.from(usedComps).sort();

        // Export avec notification
        downloadFile(JSON.stringify(template, null, 4), `${devoirId}_TEMPLATE.json`, 'application/json');
        showNotification(`üì§ Template IA export√© ! ${template.content.length} questions √† remplir`, 'info');
    }
    function saveDraftJSON() {
        const titre = document.getElementById('titre-devoir').value || "";
        const devoirId = document.getElementById('devoir-id').value || "";
        const niveau = document.getElementById('niveau-cible').value || "";

        const questions = [];
        document.querySelectorAll('.question-block').forEach((block) => {
            const type = block.dataset.type;
            const item = {
                type: type,
                qid: block.dataset.qid || ""
            };

            if (type === 'DOC') {
                item.docTitle = block.querySelector('.doc-title-input')?.value || "";
                item.docContent = block.querySelector('.doc-content')?.value || "";
                questions.push(item);
                return;
            }

            item.enonce = block.querySelector('.q-enonce')?.value || "";
            item.competence = block.querySelector('.q-comp')?.value || "C1";
            item.points = parseFloat(block.querySelector('.q-points')?.value) || 0;
            item.explanation = block.querySelector('.q-explain')?.value || "";

            if (type === 'QCU') {
                item.options = [];
                block.querySelectorAll('.option-row').forEach((row) => {
                    item.options.push({
                        text: row.querySelector('.opt-text')?.value || "",
                        correct: !!row.querySelector('.correct-check')?.checked
                    });
                });
            } else if (type === 'VF') {
                item.correct = block.querySelector('input[value="vrai"]')?.checked ? 'vrai' : 'faux';
            } else if (type === 'SHORT' || type === 'NUMBER') {
                item.validAnswers = block.querySelector('.valid-answers')?.value || "";
            } else if (type === 'BOX_NOTE') {
                item.noteContent = block.querySelector('.box-note-content')?.value || "";
            } else if (type === 'SEPARATOR' || type === 'TITLE') {
                // Pas de donn√©es suppl√©mentaires
            } else if (isEncType(type)) {
                item.titreEncadre = item.enonce;
                item.lignes = getEncRows(block).map((row) => ({
                    label: row.dataset.label || "",
                    subqid: row.dataset.subqid || createStableQid(),
                    enabled: row.dataset.enabled !== "0",
                    preview: row.querySelector('.enc-expected')?.value || ""
                }));
            }

            questions.push(item);
        });

        const draft = {
            meta: {
                titre,
                devoirId,
                niveau,
                dateISO: new Date().toISOString(),
                version: "master-quiz-auto"
            },
            questions,
            options: {}
        };

        const safeId = String(devoirId || "").trim();
        const fileName = safeId ? `${safeId}__draft.json` : `draft__${Date.now()}.json`;
        downloadFile(JSON.stringify(draft, null, 2), fileName, 'application/json');
        showNotification(`üíæ Brouillon sauvegard√© (${questions.length} blocs)`, 'info');
    }

    function restoreDraftJSON(data) {
        if (!data || !Array.isArray(data.questions)) {
            throw new Error("Format draft invalide");
        }

        const meta = data.meta || {};
        document.getElementById('titre-devoir').value = meta.titre || data.titre || "";
        document.getElementById('devoir-id').value = meta.devoirId || data.devoirId || "";
        document.getElementById('niveau-cible').value = meta.niveau || data.niveau || "";
        document.getElementById('quiz-content').innerHTML = '';
        qCount = 0;

        data.questions.forEach((q) => {
            const type = q.type || 'SHORT';

            if (type === 'DOC') {
                const contentDiv = createBlockSkeleton('DOC', null);
                const block = contentDiv.closest('.question-block');
                if (q.qid) block.dataset.qid = q.qid;
                safeSetValue(block.querySelector('.doc-title-input'), q.docTitle || "");
                safeSetValue(block.querySelector('.doc-content'), q.docContent || "");
                return;
            }

            addBlock(type, null);
            const blocks = document.querySelectorAll('.question-block:not(.doc-block)');
            const block = blocks[blocks.length - 1];
            if (!block) return;
            if (q.qid) block.dataset.qid = q.qid;

            safeSetValue(block.querySelector('.q-enonce'), q.enonce || "");
            safeSetValue(block.querySelector('.q-comp'), q.competence || "C1");
            safeSetValue(block.querySelector('.q-points'), q.points ?? 0);
            safeSetValue(block.querySelector('.q-explain'), q.explanation || "");

            if (type === 'QCU') {
                const container = block.querySelector('div[id^="opts_"]');
                if (container) {
                    container.innerHTML = '';
                    const opts = Array.isArray(q.options) ? q.options : [];
                    (opts.length ? opts : [{ text: "", correct: false }, { text: "", correct: false }]).forEach((opt) => {
                        addOption(container.id);
                        const rows = container.querySelectorAll('.option-row');
                        const row = rows[rows.length - 1];
                        safeSetValue(row.querySelector('.opt-text'), opt.text || "");
                        const ck = row.querySelector('.correct-check');
                        if (ck) ck.checked = !!opt.correct;
                    });
                }
            } else if (type === 'VF') {
                const v = (q.correct || '').toString().toLowerCase();
                const isVrai = v === 'vrai' || v === 'true' || v === 'v';
                const vraiEl = block.querySelector('input[value="vrai"]');
                const fauxEl = block.querySelector('input[value="faux"]');
                if (vraiEl) vraiEl.checked = isVrai;
                if (fauxEl) fauxEl.checked = !isVrai;
            } else if (type === 'SHORT' || type === 'NUMBER') {
                safeSetValue(block.querySelector('.valid-answers'), q.validAnswers || "");
            } else if (type === 'BOX_NOTE') {
                safeSetValue(block.querySelector('.box-note-content'), q.noteContent || "");
            } else if (type === 'SEPARATOR' || type === 'TITLE') {
                // Rien de sp√©cifique
            } else if (isEncType(type)) {
                const rows = getEncRows(block);
                const savedRows = Array.isArray(q.lignes) ? q.lignes : [];
                if (savedRows.length === 0) {
                    rows.forEach((row) => setEncRowEnabled(row, true));
                    return;
                }
                rows.forEach((row) => setEncRowEnabled(row, false));
                savedRows.forEach((line) => {
                    const row = rows.find((r) => normalizeEncLabel(r.dataset.label) === normalizeEncLabel(line.label));
                    if (!row) return;
                    row.dataset.subqid = line.subqid || row.dataset.subqid || createStableQid();
                    setEncRowEnabled(row, line.enabled !== false);
                    safeSetValue(row.querySelector('.enc-expected'), line.preview || "");
                });
            }
        });

        renumberQuestions();
        updateStats();
        document.getElementById('empty-msg').style.display = document.querySelectorAll('.question-block').length ? 'none' : 'block';
    }


    // ============================================================
    // üì• IMPORT JSON CORRIG√â (VERSION ROBUSTE)
    // ============================================================

    function importJSON() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (!confirm("‚ö†Ô∏è ATTENTION : Tout le questionnaire actuel sera effac√© et remplac√© par le contenu du fichier.\n\nContinuer ?")) {
                        return;
                    }

                    // Draft master (sauvegarde JSON)
                    const isDraftJSON = Array.isArray(data.questions) && (!Array.isArray(data.content) || (data.meta && data.meta.version === "master-quiz-auto"));
                    if (isDraftJSON) {
                        restoreDraftJSON(data);
                        showNotification("‚úÖ Draft import√© avec succ√®s", "success");
                        return;
                    }

                    // Validation import existant (template IA / blueprint)
                    if (!data.content || !Array.isArray(data.content)) {
                        throw new Error("Format JSON invalide");
                    }

                    // 1. Nettoyage
                    document.getElementById("quiz-content").innerHTML = "";
                    qCount = 0;

                    // 2. Remplissage En-t√™te
                    document.getElementById("titre-devoir").value = (data.titre || "").replace(" [√Ä COMPL√âTER]", "");
                    document.getElementById("devoir-id").value = data.devoirId || "";
                    document.getElementById("niveau-cible").value = data.niveau || "Bac Pro";

                    // 3. Reconstruction intelligente
                    showNotification("üîÑ Reconstruction en cours...", "info");

                    setTimeout(() => {
                        reconstructFromJSON(data);
                        showNotification("‚úÖ Import r√©ussi ! " + document.querySelectorAll(".question-block").length + " questions r√©cup√©r√©es.", "success");
                        updateStats();
                    }, 200);
                    
                } catch (error) {
                    alert(`Erreur : ${error.message}`);
                    console.error(error);
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    function reconstructFromJSON(data) {
        console.log("üîÑ D√©but reconstruction BLIND√âE...", data);
        const items = Array.isArray(data.content) ? data.content : [];
        const encGroups = {};
        const singles = [];

        items.forEach((item, idx) => {
            const qText = getFlexibleText(item, ['questionText', 'question', 'text', 'enonce', 'titre']);
            const match = qText.match(/^(.*)\s+‚Äî\s+(.+)$/);
            if (!match) {
                singles.push({ item, idx });
                return;
            }

            const titlePart = match[1].trim();
            const linePart = match[2].trim();
            const encType = getEncTypeFromLabel(linePart);
            if (!encType) {
                singles.push({ item, idx });
                return;
            }

            const comp = item.competence || item.comp || "C1";
            const groupKey = `${encType}|||${titlePart}|||${comp}`;
            if (!encGroups[groupKey]) {
                encGroups[groupKey] = { encType, title: titlePart, competence: comp, rows: [] };
            }
            encGroups[groupKey].rows.push({ item, label: linePart, idx });
        });

        Object.values(encGroups).forEach((group) => {
            addBlock(group.encType, null);
            const blocks = document.querySelectorAll('.question-block:not(.doc-block)');
            const block = blocks[blocks.length - 1];
            if (!block) return;

            const widgetDef = getWidgetDef(group.encType);
            const imported = widgetDef && typeof widgetDef.importFromBlueprint === "function"
                ? widgetDef.importFromBlueprint(group.rows.map((r) => r.item))
                : null;

            safeSetValue(block.querySelector('.q-enonce'), imported?.enonce || group.title);
            safeSetValue(block.querySelector('.q-comp'), imported?.competence || group.competence);
            const totalPoints = imported?.points ?? group.rows.reduce((sum, r) => sum + (parseFloat(r.item.bareme || r.item.points || 0) || 0), 0);
            safeSetValue(block.querySelector('.q-points'), Number(totalPoints.toFixed(2)));
            const firstExp = imported?.explanation || getFlexibleText(group.rows[0]?.item, ['reponseAttendue', 'explication', 'correction', 'justification']);
            safeSetValue(block.querySelector('.q-explain'), firstExp);

            const rowMap = new Map(getEncRows(block).map((r) => [normalizeEncLabel(r.dataset.label), r]));
            getEncRows(block).forEach((row) => setEncRowEnabled(row, false));
            const sourceRows = Array.isArray(imported?.lignes) ? imported.lignes : group.rows.map((entry) => ({
                label: entry.label,
                subqid: entry.item.qid,
                enabled: true,
                preview: Array.isArray(entry.item.reponseCorrecte) ? entry.item.reponseCorrecte.join("; ") : String(entry.item.reponseCorrecte || "")
            }));
            sourceRows.forEach((entry) => {
                const row = rowMap.get(normalizeEncLabel(entry.label));
                if (!row) return;
                row.dataset.subqid = entry.subqid || row.dataset.subqid || createStableQid();
                setEncRowEnabled(row, entry.enabled !== false);
                safeSetValue(row.querySelector('.enc-expected'), entry.preview || "");
            });
        });

        singles.forEach(({ item, idx }) => {
            const inType = (item.inputType || "").toLowerCase();
            let type = "SHORT";

            if (inType === "checkbox" || inType === "select") type = "QCU";
            else if (inType === "vrai_faux") type = "VF";
            else if (inType === "number") type = "NUMBER";
            else if (inType === "texte_exact" || inType === "short") type = "SHORT";

            const contentDiv = createBlockSkeleton(type, null);
            const block = contentDiv.closest('.question-block');
            const qid = item.qid || `imp_${Date.now()}_${idx}`;
            block.dataset.qid = qid;

            safeSetValue(block.querySelector('.q-comp'), item.competence || item.comp || "C1");
            safeSetValue(block.querySelector('.q-points'), parseFloat(item.bareme || item.points || 1) || 1);
            safeSetValue(block.querySelector('.q-enonce'), getFlexibleText(item, ['questionText', 'question', 'text', 'enonce', 'titre']));

            if (type === "QCU") {
                const containerId = `auto_${Date.now()}_${idx}`;
                contentDiv.innerHTML = `
                    <div class="config-zone">
                        <span class="config-label">üìù Options import√©es</span>
                        <div id="${containerId}"></div>
                        <button onclick="addOption('${containerId}')" style="margin-top:10px;font-size:0.85em;cursor:pointer;background:#eee;border:none;padding:5px 10px;border-radius:4px;">+ Ajouter option</button>
                    </div>
                `;

                const opts = Array.isArray(item.options) ? item.options : [];
                const correctRaw = Array.isArray(item.reponseCorrecte)
                    ? item.reponseCorrecte[0]
                    : (item.reponseCorrecte ?? item.correct ?? item.answer);
                const correctByValue = String(correctRaw ?? "");

                if (opts.length === 0) {
                    addOption(containerId);
                    addOption(containerId);
                } else {
                    opts.forEach((opt) => {
                        addOption(containerId);
                        const rows = document.getElementById(containerId).querySelectorAll('.option-row');
                        const row = rows[rows.length - 1];
                        const optValue = String(opt?.value ?? opt?.id ?? "");
                        const optLabel = getFlexibleText(opt, ['label', 'text', 'value', 'option']);
                        safeSetValue(row.querySelector('.opt-text'), optLabel);
                        const ck = row.querySelector('.correct-check');
                        if (ck) ck.checked = optValue === correctByValue;
                    });
                }

                addExplanationSecure(contentDiv, getFlexibleText(item, ['reponseAttendue', 'explication', 'correction', 'justification']));
            } else if (type === "VF") {
                const uid = Date.now() + Math.floor(Math.random() * 10000);
                const rep = String(item.reponseCorrecte ?? item.correct ?? "").toLowerCase();
                const isVrai = rep === 'vrai' || rep === 'true' || rep === 'v';
                contentDiv.innerHTML = `
                    <div class="config-zone" style="background:linear-gradient(135deg, #e8f5e9 0%, #f0fdf4 100%); border-color:#86efac;">
                        <span class="config-label" style="color:#15803d;">üéØ R√©ponse attendue</span>
                        <label style="margin-right:20px;font-weight:bold;color:#15803d;"><input type="radio" name="vf_${uid}" value="vrai" ${isVrai ? 'checked' : ''}> Vrai</label>
                        <label style="font-weight:bold;color:#dc2626;"><input type="radio" name="vf_${uid}" value="faux" ${!isVrai ? 'checked' : ''}> Faux</label>
                    </div>
                `;
                addExplanationSecure(contentDiv, getFlexibleText(item, ['reponseAttendue', 'explication', 'correction', 'justification']));
            } else if (type === "SHORT" || type === "NUMBER") {
                const raw = item.reponseCorrecte ?? item.correct ?? item.answer ?? "";
                const rep = Array.isArray(raw) ? raw.join('; ') : String(raw ?? "");
                contentDiv.innerHTML = `
                    <div class="config-zone">
                        <span class="config-label">üéØ R√©ponse attendue</span>
                        <textarea class="valid-answers auto-grow" rows="1" style="border:2px solid #22c55e; font-family:monospace; font-weight:bold; color:#15803d; width:100%;"></textarea>
                    </div>
                `;
                safeSetValue(contentDiv.querySelector('.valid-answers'), rep);
                addExplanationSecure(contentDiv, getFlexibleText(item, ['reponseAttendue', 'explication', 'correction', 'justification']));
            }
        });
        
        document.getElementById('empty-msg').style.display = 'none';
        console.log("‚úÖ Reconstruction termin√©e");
    }

    // === FONCTIONS UTILITAIRES BLIND√âES ===

    function getFlexibleText(item, fieldNames) {
        if (!item) return "";
        
        for (const field of fieldNames) {
            const value = item[field];
            if (value && typeof value === 'string' && value.trim()) {
                return value.trim();
            }
        }
        return "";
    }

    function safeSetValue(element, value) {
        if (!element) return;
        if (!value && value !== 0) value = "";
        
        try {
            element.value = String(value);
            if (element.classList.contains('auto-grow')) {
                autoResize(element);
            }
        } catch(e) {
            console.warn("Erreur injection texte:", e);
            element.value = "Erreur encodage";
        }
    }

    function addExplanationSecure(container, text) {
        const div = document.createElement('div');
        div.style.marginTop = "15px";
        div.innerHTML = `<textarea class="q-explain auto-grow" rows="1" placeholder="üí° Explication..." style="font-size:0.9em;color:#64748b;background:#f8fafc;border:2px dashed #cbd5e0;width:100%;border-radius:6px;padding:10px;"></textarea>`;
        container.appendChild(div);
        
        // INJECTION S√âCURIS√âE
        const textarea = div.querySelector('textarea');
        safeSetValue(textarea, text || "");
    }

    // --- SYSTEME NOTIFICATION ---
    function showNotification(message, type = 'success') {
        // Supprimer notification existante
        const existing = document.querySelector('.notification');
        if (existing) existing.remove();
        
        const notif = document.createElement('div');
        notif.className = `notification ${type}`;
        notif.textContent = message;
        document.body.appendChild(notif);
        
        // Animation d'apparition
        setTimeout(() => notif.classList.add('show'), 100);
        
        // Auto-suppression apr√®s 4 secondes
        setTimeout(() => {
            notif.classList.remove('show');
            setTimeout(() => notif.remove(), 300);
        }, 4000);
    }

    function downloadFile(content, filename, contentType) {
        const a = document.createElement('a');
        const file = new Blob([content], {type: contentType});
        a.href = URL.createObjectURL(file);
        a.download = filename;
        a.click();
    }

    // --- EXPORT AM√âLIOR√â AVEC ESPACEMENT ---
    function performExportWithDelay() {
        const devoirId = document.getElementById('devoir-id').value.trim() || `quiz_${Date.now()}`;
        const titre = document.getElementById('titre-devoir').value || "Devoir";
        const niveau = document.getElementById('niveau-cible').value || "Bac Pro";

        if (!/^[A-Za-z0-9_-]+$/.test(devoirId)) {
            alert("ID unique invalide.\nUtilisez uniquement des lettres, chiffres, tirets (-) et underscores (_).");
            return;
        }

        const blueprint = {
            id: devoirId,
            devoirId: devoirId,
            titre: titre,
            niveau: niveau,
            competences: [],
            version: "v1",
            autocorrect: true,
            options: { antiLeave: true, antiPaste: true, maxLeaves: 2 },
            content: []
        };

        const usedComps = new Set();
        let studentHtmlQuestions = "";
        let qCounter = 1;

        document.querySelectorAll('.question-block').forEach((block) => {
            const type = block.dataset.type;

            if (type === 'DOC') {
                const docTitle = block.querySelector('.doc-title-input').value;
                const content = block.querySelector('.doc-content').value.replace(/\n/g, '<br>');
                studentHtmlQuestions += `
                    <div class="document-box">
                        <h4>${docTitle}</h4>
                        <p>${content}</p>
                    </div>
                `;
                return;
            }

            const qidBase = block.dataset.qid;
            const enoncePlain = block.querySelector('.q-enonce').value.trim();
            const enonce = enoncePlain.replace(/\n/g, '<br>');
            const bareme = parseFloat(block.querySelector('.q-points').value) || 1;
            const competence = block.querySelector('.q-comp').value;
            usedComps.add(competence);
            const widgetDef = getWidgetDef(type);

            if (widgetDef) {
                const ctx = { qCounter, qidBase, enoncePlain, enonceHtml: enonce, bareme, competence };
                let widgetItems = [];
                let widgetHtml = "";
                try {
                    if (typeof widgetDef.exportToBlueprint === "function") {
                        const out = widgetDef.exportToBlueprint(block, ctx);
                        if (Array.isArray(out)) widgetItems = out;
                    }
                    if (typeof widgetDef.exportToStudentHTML === "function") {
                        widgetHtml = widgetDef.exportToStudentHTML(block, ctx) || "";
                    }
                } catch (err) {
                    console.warn("Widget export error:", type, err);
                }

                if (widgetItems.length) blueprint.content.push(...widgetItems);
                if (widgetHtml) studentHtmlQuestions += widgetHtml;
                if (widgetDef.countAsQuestion !== false && (widgetItems.length || widgetHtml)) {
                    qCounter++;
                }
                return;
            }

            if (type === 'QCU') {
                let options = [];
                let correctVal = null;
                let correctText = "";

                block.querySelectorAll('.option-row').forEach((row, idx) => {
                    const txt = row.querySelector('.opt-text').value.trim();
                    const val = `${qidBase}_opt${idx+1}`;
                    const isCorrect = row.querySelector('.correct-check').checked;
                    
                    if(txt) {
                        options.push({ value: val, label: txt });
                        if(isCorrect) {
                            if (correctVal === null) {
                                correctVal = val;
                                correctText = txt;
                            }
                        }
                    }
                });

                // Utiliser l'explication personnalis√©e ou fallback sur r√©ponse basique
                const explanation = block.querySelector('.q-explain').value.trim();
                const finalExplanation = explanation || correctText;

                blueprint.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: "select",
                    autocorrect: true,
                    questionText: enoncePlain,
                    reponseCorrecte: correctVal,
                    reponseAttendue: finalExplanation,
                    options: options
                });

                // HTML √âl√®ve (inchang√©)
                studentHtmlQuestions += `
                    <div class="question-block">
                        <span class="q-label">${qCounter}</span><span class="q-comp">${competence}</span><span class="q-points">${bareme} pts</span>
                        <div class="q-text">${enonce}</div>
                        <div class="checkbox-group">
                `;
                options.forEach(opt => {
                    studentHtmlQuestions += `<label><input type="radio" name="${qidBase}" value="${opt.value}" class="reponse-eleve" data-qid="${qidBase}"> ${opt.label}</label>`;
                });
                studentHtmlQuestions += `</div></div>`;
                qCounter++;
            }
            else if (type === 'VF') {
                const isVrai = block.querySelector('input[value="vrai"]').checked;
                blueprint.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: "vrai_faux",
                    autocorrect: true,
                    questionText: enoncePlain,
                    reponseCorrecte: isVrai ? "vrai" : "faux",
                    reponseAttendue: isVrai ? "Vrai" : "Faux"
                });

                studentHtmlQuestions += `
                    <div class="question-block">
                        <span class="q-label">${qCounter}</span><span class="q-comp">${competence}</span><span class="q-points">${bareme} pts</span>
                        <div class="q-text">${enonce}</div>
                        <div class="checkbox-group">
                            <label><input type="radio" name="${qidBase}" value="vrai" class="reponse-eleve" data-qid="${qidBase}"> Vrai</label>
                            <label><input type="radio" name="${qidBase}" value="faux" class="reponse-eleve" data-qid="${qidBase}"> Faux</label>
                        </div>
                    </div>
                `;
                qCounter++;
            }
            else if (type === 'SHORT' || type === 'NUMBER') {
                const rawVal = block.querySelector('.valid-answers').value;
                const accepted = rawVal.split(';').map(s => s.trim()).filter(s => s);
                const isNum = type === 'NUMBER';

                blueprint.content.push({
                    type: "question",
                    qid: qidBase,
                    label: qCounter.toString(),
                    competence: competence,
                    bareme: bareme,
                    inputType: isNum ? "number" : "texte_exact",
                    autocorrect: true,
                    questionText: enoncePlain,
                    reponseCorrecte: isNum ? parseFloat(accepted[0]) : accepted,
                    reponseAttendue: accepted.join(" OU "),
                    tolerance: isNum ? 0 : undefined
                });

                studentHtmlQuestions += `
                    <div class="question-block">
                        <span class="q-label">${qCounter}</span><span class="q-comp">${competence}</span><span class="q-points">${bareme} pts</span>
                        <div class="q-text">${enonce}</div>
                        <div><input type="${isNum?'number':'text'}" class="reponse-eleve answer-input" data-qid="${qidBase}" placeholder="Votre r√©ponse"></div>
                    </div>
                `;
                qCounter++;
            }
            else if (isEncType(type)) {
                const activeRows = getActiveEncRows(block);
                if (activeRows.length === 0) return;
                const explanation = block.querySelector('.q-explain')?.value?.trim() || "";
                const pointsPerRow = splitPoints(bareme, activeRows.length);

                studentHtmlQuestions += `
                    <div class="question-block">
                        <span class="q-label">${qCounter}</span><span class="q-comp">${competence}</span><span class="q-points">${bareme} pts</span>
                        <div class="q-text">${enonce}</div>
                        <div class="table-wrapper">
                            <table class="eval-table">
                                <tbody>
                `;

                activeRows.forEach((row, idx) => {
                    const lineLabel = row.dataset.label || `Ligne ${idx + 1}`;
                    const subqid = row.dataset.subqid || createStableQid();
                    row.dataset.subqid = subqid;
                    const subLabel = `${qCounter}${String.fromCharCode(97 + idx)}`;
                    blueprint.content.push({
                        type: "question",
                        qid: subqid,
                        label: subLabel,
                        competence: competence,
                        bareme: pointsPerRow[idx] ?? 0,
                        inputType: "texte_exact",
                        autocorrect: true,
                        questionText: `${enoncePlain} ‚Äî ${lineLabel}`,
                        reponseCorrecte: [],
                        reponseAttendue: explanation
                    });
                    studentHtmlQuestions += `
                        <tr>
                            <td>${lineLabel}</td>
                            <td><textarea class="reponse-eleve answer-input" data-qid="${subqid}" rows="2" style="width:100%; min-height:54px;" placeholder="Votre r√©ponse"></textarea></td>
                        </tr>
                    `;
                });

                studentHtmlQuestions += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
                qCounter++;
            }
        });

        blueprint.competences = Array.from(usedComps).sort();
        blueprint.questions = blueprint.content;
        blueprint.items = blueprint.content;

        const finalStudentHTML = generateStudentTemplate(titre, devoirId, studentHtmlQuestions, blueprint.competences, blueprint);

        downloadFile(JSON.stringify(blueprint, null, 4), `${devoirId}_blueprint.json`, 'application/json');
        showNotification(`üìÑ Blueprint t√©l√©charg√© ! Fichier √©l√®ve dans 2 secondes...`, 'info');
        
        // 2. Export fichier √©l√®ve apr√®s 2 secondes
        setTimeout(() => {
            downloadFile(finalStudentHTML, `${devoirId}_eleve.html`, 'text/html');
            showNotification(`‚úÖ Export termin√© ! 2 fichiers t√©l√©charg√©s avec succ√®s`);
        }, 2000);
    }

    // Initialisation au chargement
    document.addEventListener('DOMContentLoaded', function() {
        updateStats();
    });
</script>
</body>
</html>
